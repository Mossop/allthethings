/* eslint-disable */
import type { DocumentNode } from "graphql";
import gql from "graphql-tag";
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A (potentially binary) string encoded using base64. */
  Base64String: string;
  /** An ISO-8601 encoded date string. */
  Date: string;
  /** An ISO-8601 encoded UTC date string. */
  DateTime: string;
  /** A Git object ID. */
  GitObjectID: string;
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  GitRefname: string;
  /** Git SSH string */
  GitSSHRemote: string;
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  GitTimestamp: string;
  /** A string containing HTML code. */
  HTML: string;
  /** An ISO-8601 encoded UTC date string with millisecond precision. */
  PreciseDateTime: string;
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  URI: string;
  /** A valid x509 certificate string */
  X509Certificate: string;
};

/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The id of the invitation being accepted */
  readonly invitationId: Scalars["ID"];
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of the suggested topic. */
  readonly name: Scalars["String"];
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of AddAssigneesToAssignable */
export type AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  readonly assignableId: Scalars["ID"];
  /** The id of users to add as assignees. */
  readonly assigneeIds: ReadonlyArray<Scalars["ID"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** The contents of the comment. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars["ID"];
};

/** Autogenerated input type of AddDiscussionComment */
export type AddDiscussionCommentInput = {
  /** The contents of the comment. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the discussion to comment on. */
  readonly discussionId: Scalars["ID"];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  readonly replyToId: Maybe<Scalars["ID"]>;
};

/** Autogenerated input type of AddEnterpriseSupportEntitlement */
export type AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the Enterprise which the admin belongs to. */
  readonly enterpriseId: Scalars["ID"];
  /** The login of a member who will receive the support entitlement. */
  readonly login: Scalars["String"];
};

/** Autogenerated input type of AddLabelsToLabelable */
export type AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ids of the labels to add. */
  readonly labelIds: ReadonlyArray<Scalars["ID"]>;
  /** The id of the labelable object to add labels to. */
  readonly labelableId: Scalars["ID"];
};

/** Autogenerated input type of AddProjectCard */
export type AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  readonly contentId: Maybe<Scalars["ID"]>;
  /** The note on the card. */
  readonly note: Maybe<Scalars["String"]>;
  /** The Node ID of the ProjectColumn. */
  readonly projectColumnId: Scalars["ID"];
};

/** Autogenerated input type of AddProjectColumn */
export type AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of the column. */
  readonly name: Scalars["String"];
  /** The Node ID of the project. */
  readonly projectId: Scalars["ID"];
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type AddPullRequestReviewCommentInput = {
  /** The text of the comment. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The SHA of the commit to comment on. */
  readonly commitOID: Maybe<Scalars["GitObjectID"]>;
  /** The comment id to reply to. */
  readonly inReplyTo: Maybe<Scalars["ID"]>;
  /** The relative path of the file to comment on. */
  readonly path: Maybe<Scalars["String"]>;
  /** The line index in the diff to comment on. */
  readonly position: Maybe<Scalars["Int"]>;
  /** The node ID of the pull request reviewing */
  readonly pullRequestId: Maybe<Scalars["ID"]>;
  /** The Node ID of the review to modify. */
  readonly pullRequestReviewId: Maybe<Scalars["ID"]>;
};

/** Autogenerated input type of AddPullRequestReview */
export type AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The review line comments. */
  readonly comments: Maybe<ReadonlyArray<Maybe<DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  readonly commitOID: Maybe<Scalars["GitObjectID"]>;
  /** The event to perform on the pull request review. */
  readonly event: Maybe<PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  readonly pullRequestId: Scalars["ID"];
  /** The review line comment threads. */
  readonly threads: Maybe<ReadonlyArray<Maybe<DraftPullRequestReviewThread>>>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
export type AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  readonly line: Scalars["Int"];
  /** Path to the file being commented on. */
  readonly path: Scalars["String"];
  /** The node ID of the pull request reviewing */
  readonly pullRequestId: Maybe<Scalars["ID"]>;
  /** The Node ID of the review to modify. */
  readonly pullRequestReviewId: Maybe<Scalars["ID"]>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  readonly side: Maybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  readonly startLine: Maybe<Scalars["Int"]>;
  /** The side of the diff on which the start line resides. */
  readonly startSide: Maybe<DiffSide>;
};

/** Autogenerated input type of AddReaction */
export type AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of the emoji to react with. */
  readonly content: ReactionContent;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars["ID"];
};

/** Autogenerated input type of AddStar */
export type AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Starrable ID to star. */
  readonly starrableId: Scalars["ID"];
};

/** Autogenerated input type of AddUpvote */
export type AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the discussion or comment to upvote. */
  readonly subjectId: Scalars["ID"];
};

/** Autogenerated input type of AddVerifiableDomain */
export type AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The URL of the domain */
  readonly domain: Scalars["URI"];
  /** The ID of the owner to add the domain to */
  readonly ownerId: Scalars["ID"];
};

/** Autogenerated input type of ApproveDeployments */
export type ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Optional comment for approving deployments */
  readonly comment: Maybe<Scalars["String"]>;
  /** The ids of environments to reject deployments */
  readonly environmentIds: ReadonlyArray<Scalars["ID"]>;
  /** The node ID of the workflow run containing the pending deployments. */
  readonly workflowRunId: Scalars["ID"];
};

/** Autogenerated input type of ApproveVerifiableDomain */
export type ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the verifiable domain to approve. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of ArchiveRepository */
export type ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the repository to mark as archived. */
  readonly repositoryId: Scalars["ID"];
};

/** Ordering options for Audit Log connections. */
export type AuditLogOrder = {
  /** The ordering direction. */
  readonly direction: Maybe<OrderDirection>;
  /** The field to order Audit Logs by. */
  readonly field: Maybe<AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export enum AuditLogOrderField {
  /** Order audit log entries by timestamp */
  CreatedAt = "CREATED_AT",
}

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the pending enterprise administrator invitation. */
  readonly invitationId: Scalars["ID"];
};

/** Autogenerated input type of CancelSponsorship */
export type CancelSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  readonly sponsorId: Maybe<Scalars["ID"]>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  readonly sponsorLogin: Maybe<Scalars["String"]>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  readonly sponsorableId: Maybe<Scalars["ID"]>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  readonly sponsorableLogin: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of ChangeUserStatus */
export type ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  readonly emoji: Maybe<Scalars["String"]>;
  /** If set, the user status will not be shown after this date. */
  readonly expiresAt: Maybe<Scalars["DateTime"]>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  readonly limitedAvailability: Maybe<Scalars["Boolean"]>;
  /** A short description of your current status. */
  readonly message: Maybe<Scalars["String"]>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  readonly organizationId: Maybe<Scalars["ID"]>;
};

/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationData = {
  /** Represents an annotation's information level */
  readonly annotationLevel: CheckAnnotationLevel;
  /** The location of the annotation */
  readonly location: CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  readonly message: Scalars["String"];
  /** The path of the file to add an annotation to. */
  readonly path: Scalars["String"];
  /** Details about this annotation. */
  readonly rawDetails: Maybe<Scalars["String"]>;
  /** The title that represents the annotation. */
  readonly title: Maybe<Scalars["String"]>;
};

/** Represents an annotation's information level. */
export enum CheckAnnotationLevel {
  /** An annotation indicating an inescapable error. */
  Failure = "FAILURE",
  /** An annotation indicating some information. */
  Notice = "NOTICE",
  /** An annotation indicating an ignorable error. */
  Warning = "WARNING",
}

/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationRange = {
  /** The ending column of the range. */
  readonly endColumn: Maybe<Scalars["Int"]>;
  /** The ending line of the range. */
  readonly endLine: Scalars["Int"];
  /** The starting column of the range. */
  readonly startColumn: Maybe<Scalars["Int"]>;
  /** The starting line of the range. */
  readonly startLine: Scalars["Int"];
};

/** The possible states for a check suite or run conclusion. */
export enum CheckConclusionState {
  /** The check suite or run requires action. */
  ActionRequired = "ACTION_REQUIRED",
  /** The check suite or run has been cancelled. */
  Cancelled = "CANCELLED",
  /** The check suite or run has failed. */
  Failure = "FAILURE",
  /** The check suite or run was neutral. */
  Neutral = "NEUTRAL",
  /** The check suite or run was skipped. */
  Skipped = "SKIPPED",
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = "STALE",
  /** The check suite or run has failed at startup. */
  StartupFailure = "STARTUP_FAILURE",
  /** The check suite or run has succeeded. */
  Success = "SUCCESS",
  /** The check suite or run has timed out. */
  TimedOut = "TIMED_OUT",
}

/** Possible further actions the integrator can perform. */
export type CheckRunAction = {
  /** A short explanation of what this action would do. */
  readonly description: Scalars["String"];
  /** A reference for the action on the integrator's system. */
  readonly identifier: Scalars["String"];
  /** The text to be displayed on a button in the web UI. */
  readonly label: Scalars["String"];
};

/** The filters that are available when fetching check runs. */
export type CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  readonly appId: Maybe<Scalars["Int"]>;
  /** Filters the check runs by this name. */
  readonly checkName: Maybe<Scalars["String"]>;
  /** Filters the check runs by this type. */
  readonly checkType: Maybe<CheckRunType>;
  /** Filters the check runs by this status. */
  readonly status: Maybe<CheckStatusState>;
};

/** Descriptive details about the check run. */
export type CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  readonly annotations: Maybe<ReadonlyArray<CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  readonly images: Maybe<ReadonlyArray<CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  readonly summary: Scalars["String"];
  /** The details of the check run (supports Commonmark). */
  readonly text: Maybe<Scalars["String"]>;
  /** A title to provide for this check run. */
  readonly title: Scalars["String"];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type CheckRunOutputImage = {
  /** The alternative text for the image. */
  readonly alt: Scalars["String"];
  /** A short image description. */
  readonly caption: Maybe<Scalars["String"]>;
  /** The full URL of the image. */
  readonly imageUrl: Scalars["URI"];
};

/** The possible types of check runs. */
export enum CheckRunType {
  /** Every check run available. */
  All = "ALL",
  /** The latest check run. */
  Latest = "LATEST",
}

/** The possible states for a check suite or run status. */
export enum CheckStatusState {
  /** The check suite or run has been completed. */
  Completed = "COMPLETED",
  /** The check suite or run is in progress. */
  InProgress = "IN_PROGRESS",
  /** The check suite or run is in pending state. */
  Pending = "PENDING",
  /** The check suite or run has been queued. */
  Queued = "QUEUED",
  /** The check suite or run has been requested. */
  Requested = "REQUESTED",
  /** The check suite or run is in waiting state. */
  Waiting = "WAITING",
}

/** The auto-trigger preferences that are available for check suites. */
export type CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  readonly appId: Scalars["ID"];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  readonly setting: Scalars["Boolean"];
};

/** The filters that are available when fetching check suites. */
export type CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  readonly appId: Maybe<Scalars["Int"]>;
  /** Filters the check suites by this name. */
  readonly checkName: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of ClearLabelsFromLabelable */
export type ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The id of the labelable object to clear the labels from. */
  readonly labelableId: Scalars["ID"];
};

/** Autogenerated input type of CloneProject */
export type CloneProjectInput = {
  /** The description of the project. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Whether or not to clone the source project's workflows. */
  readonly includeWorkflows: Scalars["Boolean"];
  /** The name of the project. */
  readonly name: Scalars["String"];
  /** The visibility of the project, defaults to false (private). */
  readonly public: Maybe<Scalars["Boolean"]>;
  /** The source project to clone. */
  readonly sourceId: Scalars["ID"];
  /** The owner ID to create the project under. */
  readonly targetOwnerId: Scalars["ID"];
};

/** Autogenerated input type of CloneTemplateRepository */
export type CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** A short description of the new repository. */
  readonly description: Maybe<Scalars["String"]>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  readonly includeAllBranches: Maybe<Scalars["Boolean"]>;
  /** The name of the new repository. */
  readonly name: Scalars["String"];
  /** The ID of the owner for the new repository. */
  readonly ownerId: Scalars["ID"];
  /** The Node ID of the template repository. */
  readonly repositoryId: Scalars["ID"];
  /** Indicates the repository's visibility level. */
  readonly visibility: RepositoryVisibility;
};

/** Autogenerated input type of CloseIssue */
export type CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the issue to be closed. */
  readonly issueId: Scalars["ID"];
};

/** Autogenerated input type of ClosePullRequest */
export type ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the pull request to be closed. */
  readonly pullRequestId: Scalars["ID"];
};

/** Collaborators affiliation level with a subject. */
export enum CollaboratorAffiliation {
  /** All collaborators the authenticated user can see. */
  All = "ALL",
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  Direct = "DIRECT",
  /** All outside collaborators of an organization-owned subject. */
  Outside = "OUTSIDE",
}

/** A comment author association with repository. */
export enum CommentAuthorAssociation {
  /** Author has been invited to collaborate on the repository. */
  Collaborator = "COLLABORATOR",
  /** Author has previously committed to the repository. */
  Contributor = "CONTRIBUTOR",
  /** Author has not previously committed to GitHub. */
  FirstTimer = "FIRST_TIMER",
  /** Author has not previously committed to the repository. */
  FirstTimeContributor = "FIRST_TIME_CONTRIBUTOR",
  /** Author is a placeholder for an unclaimed user. */
  Mannequin = "MANNEQUIN",
  /** Author is a member of the organization that owns the repository. */
  Member = "MEMBER",
  /** Author has no association with the repository. */
  None = "NONE",
  /** Author is the owner of the repository. */
  Owner = "OWNER",
}

/** The possible errors that will prevent a user from updating a comment. */
export enum CommentCannotUpdateReason {
  /** Unable to create comment because repository is archived. */
  Archived = "ARCHIVED",
  /** You cannot update this comment */
  Denied = "DENIED",
  /** You must be the author or have write access to this repository to update this comment. */
  InsufficientAccess = "INSUFFICIENT_ACCESS",
  /** Unable to create comment because issue is locked. */
  Locked = "LOCKED",
  /** You must be logged in to update this comment. */
  LoginRequired = "LOGIN_REQUIRED",
  /** Repository is under maintenance. */
  Maintenance = "MAINTENANCE",
  /** At least one email address must be verified to update this comment. */
  VerifiedEmailRequired = "VERIFIED_EMAIL_REQUIRED",
}

/** Specifies an author for filtering Git commits. */
export type CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  readonly emails: Maybe<ReadonlyArray<Scalars["String"]>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  readonly id: Maybe<Scalars["ID"]>;
};

/** Ordering options for commit contribution connections. */
export type CommitContributionOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field by which to order commit contributions. */
  readonly field: CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export enum CommitContributionOrderField {
  /** Order commit contributions by how many commits they represent. */
  CommitCount = "COMMIT_COUNT",
  /** Order commit contributions by when they were made. */
  OccurredAt = "OCCURRED_AT",
}

/** A message to include with a new commit */
export type CommitMessage = {
  /** The body of the message. */
  readonly body: Maybe<Scalars["String"]>;
  /** The headline of the message. */
  readonly headline: Scalars["String"];
};

/**
 * A git ref for a commit to be appended to.
 *
 * The ref must be a branch, i.e. its fully qualified name must start
 * with `refs/heads/` (although the input is not required to be fully
 * qualified).
 *
 * The Ref may be specified by its global node ID or by the
 * repository nameWithOwner and branch name.
 *
 * ### Examples
 *
 * Specify a branch using a global node ID:
 *
 *     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
 *
 * Specify a branch using nameWithOwner and branch name:
 *
 *     {
 *       "nameWithOwner": "github/graphql-client",
 *       "branchName": "main"
 *     }
 */
export type CommittableBranch = {
  /** The unqualified name of the branch to append the commit to. */
  readonly branchName: Maybe<Scalars["String"]>;
  /** The Node ID of the Ref to be updated. */
  readonly id: Maybe<Scalars["ID"]>;
  /** The nameWithOwner of the repository to commit to. */
  readonly repositoryNameWithOwner: Maybe<Scalars["String"]>;
};

/** Varying levels of contributions from none to many. */
export enum ContributionLevel {
  /** Lowest 25% of days of contributions. */
  FirstQuartile = "FIRST_QUARTILE",
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  FourthQuartile = "FOURTH_QUARTILE",
  /** No contributions occurred. */
  None = "NONE",
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  SecondQuartile = "SECOND_QUARTILE",
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  ThirdQuartile = "THIRD_QUARTILE",
}

/** Ordering options for contribution connections. */
export type ContributionOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ProjectCard ID to convert. */
  readonly projectCardId: Scalars["ID"];
  /** The ID of the repository to create the issue in. */
  readonly repositoryId: Scalars["ID"];
  /** The title of the newly created issue. Defaults to the card's note text. */
  readonly title: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of ConvertPullRequestToDraft */
export type ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the pull request to convert to draft */
  readonly pullRequestId: Scalars["ID"];
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  readonly allowsDeletions: Maybe<Scalars["Boolean"]>;
  /** Are force pushes allowed on this branch. */
  readonly allowsForcePushes: Maybe<Scalars["Boolean"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  readonly dismissesStaleReviews: Maybe<Scalars["Boolean"]>;
  /** Can admins overwrite branch protection. */
  readonly isAdminEnforced: Maybe<Scalars["Boolean"]>;
  /** The glob-like pattern used to determine matching branches. */
  readonly pattern: Scalars["String"];
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  readonly pushActorIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  readonly repositoryId: Scalars["ID"];
  /** Number of approving reviews required to update matching branches. */
  readonly requiredApprovingReviewCount: Maybe<Scalars["Int"]>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  readonly requiredStatusCheckContexts: Maybe<ReadonlyArray<Scalars["String"]>>;
  /** Are approving reviews required to update matching branches. */
  readonly requiresApprovingReviews: Maybe<Scalars["Boolean"]>;
  /** Are reviews from code owners required to update matching branches. */
  readonly requiresCodeOwnerReviews: Maybe<Scalars["Boolean"]>;
  /** Are commits required to be signed. */
  readonly requiresCommitSignatures: Maybe<Scalars["Boolean"]>;
  /** Are conversations required to be resolved before merging. */
  readonly requiresConversationResolution: Maybe<Scalars["Boolean"]>;
  /** Are merge commits prohibited from being pushed to this branch. */
  readonly requiresLinearHistory: Maybe<Scalars["Boolean"]>;
  /** Are status checks required to update matching branches. */
  readonly requiresStatusChecks: Maybe<Scalars["Boolean"]>;
  /** Are branches required to be up to date before merging. */
  readonly requiresStrictStatusChecks: Maybe<Scalars["Boolean"]>;
  /** Is pushing to matching branches restricted. */
  readonly restrictsPushes: Maybe<Scalars["Boolean"]>;
  /** Is dismissal of pull request reviews restricted. */
  readonly restrictsReviewDismissals: Maybe<Scalars["Boolean"]>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  readonly reviewDismissalActorIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
};

/** Autogenerated input type of CreateCheckRun */
export type CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  readonly actions: Maybe<ReadonlyArray<CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The time that the check run finished. */
  readonly completedAt: Maybe<Scalars["DateTime"]>;
  /** The final conclusion of the check. */
  readonly conclusion: Maybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  readonly detailsUrl: Maybe<Scalars["URI"]>;
  /** A reference for the run on the integrator's system. */
  readonly externalId: Maybe<Scalars["String"]>;
  /** The SHA of the head commit. */
  readonly headSha: Scalars["GitObjectID"];
  /** The name of the check. */
  readonly name: Scalars["String"];
  /** Descriptive details about the run. */
  readonly output: Maybe<CheckRunOutput>;
  /** The node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
  /** The time that the check run began. */
  readonly startedAt: Maybe<Scalars["DateTime"]>;
  /** The current status. */
  readonly status: Maybe<RequestableCheckStatusState>;
};

/** Autogenerated input type of CreateCheckSuite */
export type CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The SHA of the head commit. */
  readonly headSha: Scalars["GitObjectID"];
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of CreateCommitOnBranch */
export type CreateCommitOnBranchInput = {
  /** The Ref to be updated.  Must be a branch. */
  readonly branch: CommittableBranch;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The git commit oid expected at the head of the branch prior to the commit */
  readonly expectedHeadOid: Scalars["GitObjectID"];
  /** A description of changes to files in this commit. */
  readonly fileChanges: Maybe<FileChanges>;
  /** The commit message the be included with the commit. */
  readonly message: CommitMessage;
};

/** Autogenerated input type of CreateContentAttachment */
export type CreateContentAttachmentInput = {
  /** The body of the content attachment, which may contain markdown. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The node ID of the content_reference. */
  readonly contentReferenceId: Scalars["ID"];
  /** The title of the content attachment. */
  readonly title: Scalars["String"];
};

/** Autogenerated input type of CreateDeployment */
export type CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  readonly autoMerge: Maybe<Scalars["Boolean"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Short description of the deployment. */
  readonly description: Maybe<Scalars["String"]>;
  /** Name for the target deployment environment. */
  readonly environment: Maybe<Scalars["String"]>;
  /** JSON payload with extra information about the deployment. */
  readonly payload: Maybe<Scalars["String"]>;
  /** The node ID of the ref to be deployed. */
  readonly refId: Scalars["ID"];
  /** The node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  readonly requiredContexts: Maybe<ReadonlyArray<Scalars["String"]>>;
  /** Specifies a task to execute. */
  readonly task: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of CreateDeploymentStatus */
export type CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  readonly autoInactive: Maybe<Scalars["Boolean"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The node ID of the deployment. */
  readonly deploymentId: Scalars["ID"];
  /** A short description of the status. Maximum length of 140 characters. */
  readonly description: Maybe<Scalars["String"]>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  readonly environment: Maybe<Scalars["String"]>;
  /** Sets the URL for accessing your environment. */
  readonly environmentUrl: Maybe<Scalars["String"]>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  readonly logUrl: Maybe<Scalars["String"]>;
  /** The state of the deployment. */
  readonly state: DeploymentStatusState;
};

/** Autogenerated input type of CreateDiscussion */
export type CreateDiscussionInput = {
  /** The body of the discussion. */
  readonly body: Scalars["String"];
  /** The id of the discussion category to associate with this discussion. */
  readonly categoryId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The id of the repository on which to create the discussion. */
  readonly repositoryId: Scalars["ID"];
  /** The title of the discussion. */
  readonly title: Scalars["String"];
};

/** Autogenerated input type of CreateEnterpriseOrganization */
export type CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  readonly adminLogins: ReadonlyArray<Scalars["String"]>;
  /** The email used for sending billing receipts. */
  readonly billingEmail: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise owning the new organization. */
  readonly enterpriseId: Scalars["ID"];
  /** The login of the new organization. */
  readonly login: Scalars["String"];
  /** The profile name of the new organization. */
  readonly profileName: Scalars["String"];
};

/** Autogenerated input type of CreateEnvironment */
export type CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of the environment. */
  readonly name: Scalars["String"];
  /** The node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of CreateIpAllowListEntry */
export type CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  readonly allowListValue: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  readonly isActive: Scalars["Boolean"];
  /** An optional name for the IP allow list entry. */
  readonly name: Maybe<Scalars["String"]>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  readonly ownerId: Scalars["ID"];
};

/** Autogenerated input type of CreateIssue */
export type CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  readonly assigneeIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The body for the issue description. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  readonly issueTemplate: Maybe<Scalars["String"]>;
  /** An array of Node IDs of labels for this issue. */
  readonly labelIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The Node ID of the milestone for this issue. */
  readonly milestoneId: Maybe<Scalars["ID"]>;
  /** An array of Node IDs for projects associated with this issue. */
  readonly projectIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
  /** The title for the issue. */
  readonly title: Scalars["String"];
};

/** Autogenerated input type of CreateLabel */
export type CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  readonly color: Scalars["String"];
  /** A brief description of the label, such as its purpose. */
  readonly description: Maybe<Scalars["String"]>;
  /** The name of the label. */
  readonly name: Scalars["String"];
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  /** The description of project. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of project. */
  readonly name: Scalars["String"];
  /** The owner ID to create the project under. */
  readonly ownerId: Scalars["ID"];
  /** A list of repository IDs to create as linked repositories for the project */
  readonly repositoryIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The name of the GitHub-provided template. */
  readonly template: Maybe<ProjectTemplate>;
};

/** Autogenerated input type of CreatePullRequest */
export type CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  readonly baseRefName: Scalars["String"];
  /** The contents of the pull request. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Indicates whether this pull request should be a draft. */
  readonly draft: Maybe<Scalars["Boolean"]>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  readonly headRefName: Scalars["String"];
  /** Indicates whether maintainers can modify the pull request. */
  readonly maintainerCanModify: Maybe<Scalars["Boolean"]>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
  /** The title of the pull request. */
  readonly title: Scalars["String"];
};

/** Autogenerated input type of CreateRef */
export type CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  readonly name: Scalars["String"];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  readonly oid: Scalars["GitObjectID"];
  /** The Node ID of the Repository to create the Ref in. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of CreateRepository */
export type CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** A short description of the new repository. */
  readonly description: Maybe<Scalars["String"]>;
  /** Indicates if the repository should have the issues feature enabled. */
  readonly hasIssuesEnabled: Maybe<Scalars["Boolean"]>;
  /** Indicates if the repository should have the wiki feature enabled. */
  readonly hasWikiEnabled: Maybe<Scalars["Boolean"]>;
  /** The URL for a web page about this repository. */
  readonly homepageUrl: Maybe<Scalars["URI"]>;
  /** The name of the new repository. */
  readonly name: Scalars["String"];
  /** The ID of the owner for the new repository. */
  readonly ownerId: Maybe<Scalars["ID"]>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  readonly teamId: Maybe<Scalars["ID"]>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  readonly template: Maybe<Scalars["Boolean"]>;
  /** Indicates the repository's visibility level. */
  readonly visibility: RepositoryVisibility;
};

/** Autogenerated input type of CreateSponsorship */
export type CreateSponsorshipInput = {
  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */
  readonly amount: Maybe<Scalars["Int"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */
  readonly isRecurring: Maybe<Scalars["Boolean"]>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  readonly privacyLevel: Maybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  readonly receiveEmails: Maybe<Scalars["Boolean"]>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  readonly sponsorId: Maybe<Scalars["ID"]>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  readonly sponsorLogin: Maybe<Scalars["String"]>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  readonly sponsorableId: Maybe<Scalars["ID"]>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  readonly sponsorableLogin: Maybe<Scalars["String"]>;
  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */
  readonly tierId: Maybe<Scalars["ID"]>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type CreateTeamDiscussionCommentInput = {
  /** The content of the comment. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the discussion to which the comment belongs. */
  readonly discussionId: Scalars["ID"];
};

/** Autogenerated input type of CreateTeamDiscussion */
export type CreateTeamDiscussionInput = {
  /** The content of the discussion. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization admins. If false or not specified, allows any organization member
   * to view this discussion.
   */
  readonly private: Maybe<Scalars["Boolean"]>;
  /** The ID of the team to which the discussion belongs. */
  readonly teamId: Scalars["ID"];
  /** The title of the discussion. */
  readonly title: Scalars["String"];
};

/** Autogenerated input type of DeclineTopicSuggestion */
export type DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of the suggested topic. */
  readonly name: Scalars["String"];
  /** The reason why the suggested topic is declined. */
  readonly reason: TopicSuggestionDeclineReason;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
};

/** The possible base permissions for repositories. */
export enum DefaultRepositoryPermissionField {
  /** Can read, write, and administrate repos by default */
  Admin = "ADMIN",
  /** No access */
  None = "NONE",
  /** Can read repos by default */
  Read = "READ",
  /** Can read and write repos by default */
  Write = "WRITE",
}

/** Autogenerated input type of DeleteBranchProtectionRule */
export type DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  readonly branchProtectionRuleId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DeleteDeployment */
export type DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the deployment to be deleted. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeleteDiscussionComment */
export type DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node id of the discussion comment to delete. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeleteDiscussion */
export type DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The id of the discussion to delete. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeleteEnvironment */
export type DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the environment to be deleted. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeleteIpAllowListEntry */
export type DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the IP allow list entry to delete. */
  readonly ipAllowListEntryId: Scalars["ID"];
};

/** Autogenerated input type of DeleteIssueComment */
export type DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the comment to delete. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeleteIssue */
export type DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the issue to delete. */
  readonly issueId: Scalars["ID"];
};

/** Autogenerated input type of DeleteLabel */
export type DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the label to be deleted. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeletePackageVersion */
export type DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the package version to be deleted. */
  readonly packageVersionId: Scalars["ID"];
};

/** Autogenerated input type of DeleteProjectCard */
export type DeleteProjectCardInput = {
  /** The id of the card to delete. */
  readonly cardId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DeleteProjectColumn */
export type DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The id of the column to delete. */
  readonly columnId: Scalars["ID"];
};

/** Autogenerated input type of DeleteProject */
export type DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Project ID to update. */
  readonly projectId: Scalars["ID"];
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the comment to delete. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeletePullRequestReview */
export type DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the pull request review to delete. */
  readonly pullRequestReviewId: Scalars["ID"];
};

/** Autogenerated input type of DeleteRef */
export type DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the Ref to be deleted. */
  readonly refId: Scalars["ID"];
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the comment to delete. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The discussion ID to delete. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of DeleteVerifiableDomain */
export type DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the verifiable domain to delete. */
  readonly id: Scalars["ID"];
};

/** Ordering options for deployment connections */
export type DeploymentOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order deployments by. */
  readonly field: DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export enum DeploymentOrderField {
  /** Order collection by creation time */
  CreatedAt = "CREATED_AT",
}

/** The possible protection rule types. */
export enum DeploymentProtectionRuleType {
  /** Required reviewers */
  RequiredReviewers = "REQUIRED_REVIEWERS",
  /** Wait timer */
  WaitTimer = "WAIT_TIMER",
}

/** The possible states for a deployment review. */
export enum DeploymentReviewState {
  /** The deployment was approved. */
  Approved = "APPROVED",
  /** The deployment was rejected. */
  Rejected = "REJECTED",
}

/** The possible states in which a deployment can be. */
export enum DeploymentState {
  /** The pending deployment was not updated after 30 minutes. */
  Abandoned = "ABANDONED",
  /** The deployment is currently active. */
  Active = "ACTIVE",
  /** An inactive transient deployment. */
  Destroyed = "DESTROYED",
  /** The deployment experienced an error. */
  Error = "ERROR",
  /** The deployment has failed. */
  Failure = "FAILURE",
  /** The deployment is inactive. */
  Inactive = "INACTIVE",
  /** The deployment is in progress. */
  InProgress = "IN_PROGRESS",
  /** The deployment is pending. */
  Pending = "PENDING",
  /** The deployment has queued */
  Queued = "QUEUED",
  /** The deployment is waiting. */
  Waiting = "WAITING",
}

/** The possible states for a deployment status. */
export enum DeploymentStatusState {
  /** The deployment experienced an error. */
  Error = "ERROR",
  /** The deployment has failed. */
  Failure = "FAILURE",
  /** The deployment is inactive. */
  Inactive = "INACTIVE",
  /** The deployment is in progress. */
  InProgress = "IN_PROGRESS",
  /** The deployment is pending. */
  Pending = "PENDING",
  /** The deployment is queued */
  Queued = "QUEUED",
  /** The deployment was successful. */
  Success = "SUCCESS",
  /** The deployment is waiting. */
  Waiting = "WAITING",
}

/** The possible sides of a diff. */
export enum DiffSide {
  /** The left side of the diff. */
  Left = "LEFT",
  /** The right side of the diff. */
  Right = "RIGHT",
}

/** Autogenerated input type of DisablePullRequestAutoMerge */
export type DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the pull request to disable auto merge on. */
  readonly pullRequestId: Scalars["ID"];
};

/** Ways in which lists of discussions can be ordered upon return. */
export type DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  readonly direction: OrderDirection;
  /** The field by which to order discussions. */
  readonly field: DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
export enum DiscussionOrderField {
  /** Order discussions by creation time. */
  CreatedAt = "CREATED_AT",
  /** Order discussions by most recent modification time. */
  UpdatedAt = "UPDATED_AT",
}

/** Autogenerated input type of DismissPullRequestReview */
export type DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The contents of the pull request review dismissal message. */
  readonly message: Scalars["String"];
  /** The Node ID of the pull request review to modify. */
  readonly pullRequestReviewId: Scalars["ID"];
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  readonly body: Scalars["String"];
  /** Path to the file being commented on. */
  readonly path: Scalars["String"];
  /** Position in the file to leave a comment on. */
  readonly position: Scalars["Int"];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  readonly body: Scalars["String"];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  readonly line: Scalars["Int"];
  /** Path to the file being commented on. */
  readonly path: Scalars["String"];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  readonly side: Maybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  readonly startLine: Maybe<Scalars["Int"]>;
  /** The side of the diff on which the start line resides. */
  readonly startSide: Maybe<DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
export type EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  readonly authorEmail: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Commit body to use for the commit when the PR is mergable; if omitted, a default message will be used. */
  readonly commitBody: Maybe<Scalars["String"]>;
  /** Commit headline to use for the commit when the PR is mergable; if omitted, a default message will be used. */
  readonly commitHeadline: Maybe<Scalars["String"]>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  readonly mergeMethod: Maybe<PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  readonly pullRequestId: Scalars["ID"];
};

/** Ordering options for enterprise administrator invitation connections */
export type EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  readonly field: EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export enum EnterpriseAdministratorInvitationOrderField {
  /** Order enterprise administrator member invitations by creation time */
  CreatedAt = "CREATED_AT",
}

/** The possible administrator roles in an enterprise account. */
export enum EnterpriseAdministratorRole {
  /** Represents a billing manager of the enterprise account. */
  BillingManager = "BILLING_MANAGER",
  /** Represents an owner of the enterprise account. */
  Owner = "OWNER",
}

/** The possible values for the enterprise base repository permission setting. */
export enum EnterpriseDefaultRepositoryPermissionSettingValue {
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  Admin = "ADMIN",
  /** Organization members will only be able to clone and pull public repositories. */
  None = "NONE",
  /** Organizations in the enterprise choose base repository permissions for their members. */
  NoPolicy = "NO_POLICY",
  /** Organization members will be able to clone and pull all organization repositories. */
  Read = "READ",
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  Write = "WRITE",
}

/** The possible values for an enabled/disabled enterprise setting. */
export enum EnterpriseEnabledDisabledSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = "DISABLED",
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = "ENABLED",
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = "NO_POLICY",
}

/** The possible values for an enabled/no policy enterprise setting. */
export enum EnterpriseEnabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = "ENABLED",
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = "NO_POLICY",
}

/** Ordering options for enterprise member connections. */
export type EnterpriseMemberOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order enterprise members by. */
  readonly field: EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export enum EnterpriseMemberOrderField {
  /** Order enterprise members by creation time */
  CreatedAt = "CREATED_AT",
  /** Order enterprise members by login */
  Login = "LOGIN",
}

/** The possible values for the enterprise members can create repositories setting. */
export enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = "ALL",
  /** Members will not be able to create public or private repositories. */
  Disabled = "DISABLED",
  /** Organization administrators choose whether to allow members to create repositories. */
  NoPolicy = "NO_POLICY",
  /** Members will be able to create only private repositories. */
  Private = "PRIVATE",
  /** Members will be able to create only public repositories. */
  Public = "PUBLIC",
}

/** The possible values for the members can make purchases setting. */
export enum EnterpriseMembersCanMakePurchasesSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = "DISABLED",
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = "ENABLED",
}

/** Ordering options for Enterprise Server installation connections. */
export type EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order Enterprise Server installations by. */
  readonly field: EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export enum EnterpriseServerInstallationOrderField {
  /** Order Enterprise Server installations by creation time */
  CreatedAt = "CREATED_AT",
  /** Order Enterprise Server installations by customer name */
  CustomerName = "CUSTOMER_NAME",
  /** Order Enterprise Server installations by host name */
  HostName = "HOST_NAME",
}

/** Ordering options for Enterprise Server user account email connections. */
export type EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order emails by. */
  readonly field: EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export enum EnterpriseServerUserAccountEmailOrderField {
  /** Order emails by email */
  Email = "EMAIL",
}

/** Ordering options for Enterprise Server user account connections. */
export type EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order user accounts by. */
  readonly field: EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export enum EnterpriseServerUserAccountOrderField {
  /** Order user accounts by login */
  Login = "LOGIN",
  /** Order user accounts by creation time on the Enterprise Server installation */
  RemoteCreatedAt = "REMOTE_CREATED_AT",
}

/** Ordering options for Enterprise Server user accounts upload connections. */
export type EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order user accounts uploads by. */
  readonly field: EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export enum EnterpriseServerUserAccountsUploadOrderField {
  /** Order user accounts uploads by creation time */
  CreatedAt = "CREATED_AT",
}

/** Synchronization state of the Enterprise Server user accounts upload */
export enum EnterpriseServerUserAccountsUploadSyncState {
  /** The synchronization of the upload failed. */
  Failure = "FAILURE",
  /** The synchronization of the upload is pending. */
  Pending = "PENDING",
  /** The synchronization of the upload succeeded. */
  Success = "SUCCESS",
}

/** The possible roles for enterprise membership. */
export enum EnterpriseUserAccountMembershipRole {
  /** The user is a member of the enterprise membership. */
  Member = "MEMBER",
  /** The user is an owner of the enterprise membership. */
  Owner = "OWNER",
}

/** The possible GitHub Enterprise deployments where this user can exist. */
export enum EnterpriseUserDeployment {
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  Cloud = "CLOUD",
  /** The user is part of a GitHub Enterprise Server deployment. */
  Server = "SERVER",
}

/**
 * A command to add a file at the given path with the given contents as part of a
 * commit.  Any existing file at that that path will be replaced.
 */
export type FileAddition = {
  /** The base64 encoded contents of the file */
  readonly contents: Scalars["Base64String"];
  /** The path in the repository where the file will be located */
  readonly path: Scalars["String"];
};

/**
 * A description of a set of changes to a file tree to be made as part of
 * a git commit, modeled as zero or more file `additions` and zero or more
 * file `deletions`.
 *
 * Both fields are optional; omitting both will produce a commit with no
 * file changes.
 *
 * `deletions` and `additions` describe changes to files identified
 * by their path in the git tree using unix-style path separators, i.e.
 * `/`.  The root of a git tree is an empty string, so paths are not
 * slash-prefixed.
 *
 * `path` values must be unique across all `additions` and `deletions`
 * provided.  Any duplication will result in a validation error.
 *
 * ### Encoding
 *
 * File contents must be provided in full for each `FileAddition`.
 *
 * The `contents` of a `FileAddition` must be encoded using RFC 4648
 * compliant base64, i.e. correct padding is required and no characters
 * outside the standard alphabet may be used.  Invalid base64
 * encoding will be rejected with a validation error.
 *
 * The encoded contents may be binary.
 *
 * For text files, no assumptions are made about the character encoding of
 * the file contents (after base64 decoding).  No charset transcoding or
 * line-ending normalization will be performed; it is the client's
 * responsibility to manage the character encoding of files they provide.
 * However, for maximum compatibility we recommend using UTF-8 encoding
 * and ensuring that all files in a repository use a consistent
 * line-ending convention (`\n` or `\r\n`), and that all files end
 * with a newline.
 *
 * ### Modeling file changes
 *
 * Each of the the five types of conceptual changes that can be made in a
 * git commit can be described using the `FileChanges` type as follows:
 *
 * 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 * 2. Existing file modification: change existing `docs/README.txt` to have new
 *    content `new content here\n`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("new content here\n")
 *            }
 *          ]
 *        }
 *
 * 3. Existing file deletion: remove existing file `docs/README.txt`.
 *    Note that the path is required to exist -- specifying a
 *    path that does not exist on the given branch will abort the
 *    commit and return an error.
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt"
 *            }
 *          ]
 *        }
 *
 *
 * 4. File rename with no changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to the same content at
 *    `newdocs/README.txt`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 *
 * 5. File rename with changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to a file at path
 *    `newdocs/README.txt` with content `new contents\n`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("new contents\n")
 *            }
 *          ]
 *        }
 */
export type FileChanges = {
  /** File to add or change. */
  readonly additions: Maybe<ReadonlyArray<FileAddition>>;
  /** Files to delete. */
  readonly deletions: Maybe<ReadonlyArray<FileDeletion>>;
};

/** A command to delete the file at the given path as part of a commit. */
export type FileDeletion = {
  /** The path to delete */
  readonly path: Scalars["String"];
};

/** The possible viewed states of a file . */
export enum FileViewedState {
  /** The file has new changes since last viewed. */
  Dismissed = "DISMISSED",
  /** The file has not been marked as viewed. */
  Unviewed = "UNVIEWED",
  /** The file has been marked as viewed. */
  Viewed = "VIEWED",
}

/** Autogenerated input type of FollowUser */
export type FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the user to follow. */
  readonly userId: Scalars["ID"];
};

/** The possible funding platforms for repository funding links. */
export enum FundingPlatform {
  /** Community Bridge funding platform. */
  CommunityBridge = "COMMUNITY_BRIDGE",
  /** Custom funding platform. */
  Custom = "CUSTOM",
  /** GitHub funding platform. */
  Github = "GITHUB",
  /** IssueHunt funding platform. */
  Issuehunt = "ISSUEHUNT",
  /** Ko-fi funding platform. */
  KoFi = "KO_FI",
  /** Liberapay funding platform. */
  Liberapay = "LIBERAPAY",
  /** Open Collective funding platform. */
  OpenCollective = "OPEN_COLLECTIVE",
  /** Otechie funding platform. */
  Otechie = "OTECHIE",
  /** Patreon funding platform. */
  Patreon = "PATREON",
  /** Tidelift funding platform. */
  Tidelift = "TIDELIFT",
}

/** Ordering options for gist connections */
export type GistOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order repositories by. */
  readonly field: GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export enum GistOrderField {
  /** Order gists by creation time */
  CreatedAt = "CREATED_AT",
  /** Order gists by push time */
  PushedAt = "PUSHED_AT",
  /** Order gists by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The privacy of a Gist */
export enum GistPrivacy {
  /** Gists that are public and secret */
  All = "ALL",
  /** Public */
  Public = "PUBLIC",
  /** Secret */
  Secret = "SECRET",
}

/** The state of a Git signature. */
export enum GitSignatureState {
  /** The signing certificate or its chain could not be verified */
  BadCert = "BAD_CERT",
  /** Invalid email used for signing */
  BadEmail = "BAD_EMAIL",
  /** Signing key expired */
  ExpiredKey = "EXPIRED_KEY",
  /** Internal error - the GPG verification service misbehaved */
  GpgverifyError = "GPGVERIFY_ERROR",
  /** Internal error - the GPG verification service is unavailable at the moment */
  GpgverifyUnavailable = "GPGVERIFY_UNAVAILABLE",
  /** Invalid signature */
  Invalid = "INVALID",
  /** Malformed signature */
  MalformedSig = "MALFORMED_SIG",
  /** The usage flags for the key that signed this don't allow signing */
  NotSigningKey = "NOT_SIGNING_KEY",
  /** Email used for signing not known to GitHub */
  NoUser = "NO_USER",
  /** Valid signature, though certificate revocation check failed */
  OcspError = "OCSP_ERROR",
  /** Valid signature, pending certificate revocation checking */
  OcspPending = "OCSP_PENDING",
  /** One or more certificates in chain has been revoked */
  OcspRevoked = "OCSP_REVOKED",
  /** Key used for signing not known to GitHub */
  UnknownKey = "UNKNOWN_KEY",
  /** Unknown signature type */
  UnknownSigType = "UNKNOWN_SIG_TYPE",
  /** Unsigned */
  Unsigned = "UNSIGNED",
  /** Email used for signing unverified on GitHub */
  UnverifiedEmail = "UNVERIFIED_EMAIL",
  /** Valid signature and verified by GitHub */
  Valid = "VALID",
}

/** The possible states in which authentication can be configured with an identity provider. */
export enum IdentityProviderConfigurationState {
  /** Authentication with an identity provider is configured but not enforced. */
  Configured = "CONFIGURED",
  /** Authentication with an identity provider is configured and enforced. */
  Enforced = "ENFORCED",
  /** Authentication with an identity provider is not configured. */
  Unconfigured = "UNCONFIGURED",
}

/** Autogenerated input type of ImportProject */
export type ImportProjectInput = {
  /** The description of Project. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** A list of columns containing issues and pull requests. */
  readonly columnImports: ReadonlyArray<ProjectColumnImport>;
  /** The name of Project. */
  readonly name: Scalars["String"];
  /** The name of the Organization or User to create the Project under. */
  readonly ownerName: Scalars["String"];
  /** Whether the Project is public or not. */
  readonly public: Maybe<Scalars["Boolean"]>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The email of the person to invite as an administrator. */
  readonly email: Maybe<Scalars["String"]>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  readonly enterpriseId: Scalars["ID"];
  /** The login of a user to invite as an administrator. */
  readonly invitee: Maybe<Scalars["String"]>;
  /** The role of the administrator. */
  readonly role: Maybe<EnterpriseAdministratorRole>;
};

/** The possible values for the IP allow list enabled setting. */
export enum IpAllowListEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = "DISABLED",
  /** The setting is enabled for the owner. */
  Enabled = "ENABLED",
}

/** Ordering options for IP allow list entry connections. */
export type IpAllowListEntryOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order IP allow list entries by. */
  readonly field: IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export enum IpAllowListEntryOrderField {
  /** Order IP allow list entries by the allow list value. */
  AllowListValue = "ALLOW_LIST_VALUE",
  /** Order IP allow list entries by creation time. */
  CreatedAt = "CREATED_AT",
}

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
export enum IpAllowListForInstalledAppsEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = "DISABLED",
  /** The setting is enabled for the owner. */
  Enabled = "ENABLED",
}

/** Ways in which lists of issue comments can be ordered upon return. */
export type IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order issue comments by. */
  readonly field: IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
export enum IssueCommentOrderField {
  /** Order issue comments by update time */
  UpdatedAt = "UPDATED_AT",
}

/** Ways in which to filter lists of issues. */
export type IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  readonly assignee: Maybe<Scalars["String"]>;
  /** List issues created by given name. */
  readonly createdBy: Maybe<Scalars["String"]>;
  /** List issues where the list of label names exist on the issue. */
  readonly labels: Maybe<ReadonlyArray<Scalars["String"]>>;
  /** List issues where the given name is mentioned in the issue. */
  readonly mentioned: Maybe<Scalars["String"]>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  readonly milestone: Maybe<Scalars["String"]>;
  /** List issues that have been updated at or after the given date. */
  readonly since: Maybe<Scalars["DateTime"]>;
  /** List issues filtered by the list of states given. */
  readonly states: Maybe<ReadonlyArray<IssueState>>;
  /** List issues subscribed to by viewer. */
  readonly viewerSubscribed: Maybe<Scalars["Boolean"]>;
};

/** Ways in which lists of issues can be ordered upon return. */
export type IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order issues by. */
  readonly field: IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export enum IssueOrderField {
  /** Order issues by comment count */
  Comments = "COMMENTS",
  /** Order issues by creation time */
  CreatedAt = "CREATED_AT",
  /** Order issues by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The possible states of an issue. */
export enum IssueState {
  /** An issue that has been closed */
  Closed = "CLOSED",
  /** An issue that is still open */
  Open = "OPEN",
}

/** The possible item types found in a timeline. */
export enum IssueTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = "ADDED_TO_PROJECT_EVENT",
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = "ASSIGNED_EVENT",
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = "CLOSED_EVENT",
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = "COMMENT_DELETED_EVENT",
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = "CONNECTED_EVENT",
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = "CROSS_REFERENCED_EVENT",
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = "DEMILESTONED_EVENT",
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = "DISCONNECTED_EVENT",
  /** Represents a comment on an Issue. */
  IssueComment = "ISSUE_COMMENT",
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = "LABELED_EVENT",
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = "LOCKED_EVENT",
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = "MARKED_AS_DUPLICATE_EVENT",
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = "MENTIONED_EVENT",
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = "MILESTONED_EVENT",
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = "PINNED_EVENT",
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = "REFERENCED_EVENT",
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = "REMOVED_FROM_PROJECT_EVENT",
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = "RENAMED_TITLE_EVENT",
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = "REOPENED_EVENT",
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = "SUBSCRIBED_EVENT",
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = "TRANSFERRED_EVENT",
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = "UNASSIGNED_EVENT",
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = "UNLABELED_EVENT",
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = "UNLOCKED_EVENT",
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = "UNMARKED_AS_DUPLICATE_EVENT",
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = "UNPINNED_EVENT",
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = "UNSUBSCRIBED_EVENT",
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = "USER_BLOCKED_EVENT",
}

/** Ways in which lists of labels can be ordered upon return. */
export type LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order labels by. */
  readonly field: LabelOrderField;
};

/** Properties by which label connections can be ordered. */
export enum LabelOrderField {
  /** Order labels by creation time */
  CreatedAt = "CREATED_AT",
  /** Order labels by name */
  Name = "NAME",
}

/** Ordering options for language connections. */
export type LanguageOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order languages by. */
  readonly field: LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export enum LanguageOrderField {
  /** Order languages by the size of all files containing the language */
  Size = "SIZE",
}

/** Autogenerated input type of LinkRepositoryToProject */
export type LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the Project to link to a Repository */
  readonly projectId: Scalars["ID"];
  /** The ID of the Repository to link to a Project. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of LockLockable */
export type LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** A reason for why the item will be locked. */
  readonly lockReason: Maybe<LockReason>;
  /** ID of the item to be locked. */
  readonly lockableId: Scalars["ID"];
};

/** The possible reasons that an issue or pull request was locked. */
export enum LockReason {
  /** The issue or pull request was locked because the conversation was off-topic. */
  OffTopic = "OFF_TOPIC",
  /** The issue or pull request was locked because the conversation was resolved. */
  Resolved = "RESOLVED",
  /** The issue or pull request was locked because the conversation was spam. */
  Spam = "SPAM",
  /** The issue or pull request was locked because the conversation was too heated. */
  TooHeated = "TOO_HEATED",
}

/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
export type MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the discussion comment to mark as an answer. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of MarkFileAsViewed */
export type MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The path of the file to mark as viewed */
  readonly path: Scalars["String"];
  /** The Node ID of the pull request. */
  readonly pullRequestId: Scalars["ID"];
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
export type MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the pull request to be marked as ready for review. */
  readonly pullRequestId: Scalars["ID"];
};

/** Autogenerated input type of MergeBranch */
export type MergeBranchInput = {
  /** The email address to associate with this commit. */
  readonly authorEmail: Maybe<Scalars["String"]>;
  /** The name of the base branch that the provided head will be merged into. */
  readonly base: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  readonly commitMessage: Maybe<Scalars["String"]>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  readonly head: Scalars["String"];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of MergePullRequest */
export type MergePullRequestInput = {
  /** The email address to associate with this merge. */
  readonly authorEmail: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  readonly commitBody: Maybe<Scalars["String"]>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  readonly commitHeadline: Maybe<Scalars["String"]>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  readonly expectedHeadOid: Maybe<Scalars["GitObjectID"]>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  readonly mergeMethod: Maybe<PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  readonly pullRequestId: Scalars["ID"];
};

/** Detailed status information about a pull request merge. */
export enum MergeStateStatus {
  /** The head ref is out of date. */
  Behind = "BEHIND",
  /** The merge is blocked. */
  Blocked = "BLOCKED",
  /** Mergeable and passing commit status. */
  Clean = "CLEAN",
  /** The merge commit cannot be cleanly created. */
  Dirty = "DIRTY",
  /** The merge is blocked due to the pull request being a draft. */
  Draft = "DRAFT",
  /** Mergeable with passing commit status and pre-receive hooks. */
  HasHooks = "HAS_HOOKS",
  /** The state cannot currently be determined. */
  Unknown = "UNKNOWN",
  /** Mergeable with non-passing commit status. */
  Unstable = "UNSTABLE",
}

/** Whether or not a PullRequest can be merged. */
export enum MergeableState {
  /** The pull request cannot be merged due to merge conflicts. */
  Conflicting = "CONFLICTING",
  /** The pull request can be merged. */
  Mergeable = "MERGEABLE",
  /** The mergeability of the pull request is still being calculated. */
  Unknown = "UNKNOWN",
}

/** Ordering options for milestone connections. */
export type MilestoneOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order milestones by. */
  readonly field: MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export enum MilestoneOrderField {
  /** Order milestones by when they were created. */
  CreatedAt = "CREATED_AT",
  /** Order milestones by when they are due. */
  DueDate = "DUE_DATE",
  /** Order milestones by their number. */
  Number = "NUMBER",
  /** Order milestones by when they were last updated. */
  UpdatedAt = "UPDATED_AT",
}

/** The possible states of a milestone. */
export enum MilestoneState {
  /** A milestone that has been closed. */
  Closed = "CLOSED",
  /** A milestone that is still open. */
  Open = "OPEN",
}

/** Autogenerated input type of MinimizeComment */
export type MinimizeCommentInput = {
  /** The classification of comment */
  readonly classifier: ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars["ID"];
};

/** Autogenerated input type of MoveProjectCard */
export type MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  readonly afterCardId: Maybe<Scalars["ID"]>;
  /** The id of the card to move. */
  readonly cardId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The id of the column to move it into. */
  readonly columnId: Scalars["ID"];
};

/** Autogenerated input type of MoveProjectColumn */
export type MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  readonly afterColumnId: Maybe<Scalars["ID"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The id of the column to move. */
  readonly columnId: Scalars["ID"];
};

/** The possible values for the notification restriction setting. */
export enum NotificationRestrictionSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = "DISABLED",
  /** The setting is enabled for the owner. */
  Enabled = "ENABLED",
}

/** The state of an OAuth Application when it was created. */
export enum OauthApplicationCreateAuditEntryState {
  /** The OAuth Application was active and allowed to have OAuth Accesses. */
  Active = "ACTIVE",
  /** The OAuth Application was in the process of being deleted. */
  PendingDeletion = "PENDING_DELETION",
  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = "SUSPENDED",
}

/** The corresponding operation type for the action */
export enum OperationType {
  /** An existing resource was accessed */
  Access = "ACCESS",
  /** A resource performed an authentication event */
  Authentication = "AUTHENTICATION",
  /** A new resource was created */
  Create = "CREATE",
  /** An existing resource was modified */
  Modify = "MODIFY",
  /** An existing resource was removed */
  Remove = "REMOVE",
  /** An existing resource was restored */
  Restore = "RESTORE",
  /** An existing resource was transferred between multiple resources */
  Transfer = "TRANSFER",
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = "ASC",
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = "DESC",
}

/** The permissions available to members on an Organization. */
export enum OrgAddMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = "ADMIN",
  /** Can read and clone repositories. */
  Read = "READ",
}

/** The billing plans available for organizations. */
export enum OrgCreateAuditEntryBillingPlan {
  /** Team Plan */
  Business = "BUSINESS",
  /** Enterprise Cloud Plan */
  BusinessPlus = "BUSINESS_PLUS",
  /** Free Plan */
  Free = "FREE",
  /** Tiered Per Seat Plan */
  TieredPerSeat = "TIERED_PER_SEAT",
  /** Legacy Unlimited Plan */
  Unlimited = "UNLIMITED",
}

/** The reason a billing manager was removed from an Organization. */
export enum OrgRemoveBillingManagerAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = "SAML_EXTERNAL_IDENTITY_MISSING",
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY",
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
}

/** The type of membership a user has with an Organization. */
export enum OrgRemoveMemberAuditEntryMembershipType {
  /**
   * Organization administrators have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization admins can delete the organization
   * and all of its repositories.
   */
  Admin = "ADMIN",
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = "BILLING_MANAGER",
  /** A direct member is a user that is a member of the Organization. */
  DirectMember = "DIRECT_MEMBER",
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = "OUTSIDE_COLLABORATOR",
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  Unaffiliated = "UNAFFILIATED",
}

/** The reason a member was removed from an Organization. */
export enum OrgRemoveMemberAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = "SAML_EXTERNAL_IDENTITY_MISSING",
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY",
  /** User was removed from organization during account recovery */
  TwoFactorAccountRecovery = "TWO_FACTOR_ACCOUNT_RECOVERY",
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
  /** User account has been deleted */
  UserAccountDeleted = "USER_ACCOUNT_DELETED",
}

/** The type of membership a user has with an Organization. */
export enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = "BILLING_MANAGER",
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = "OUTSIDE_COLLABORATOR",
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  Unaffiliated = "UNAFFILIATED",
}

/** The reason an outside collaborator was removed from an Organization. */
export enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = "SAML_EXTERNAL_IDENTITY_MISSING",
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
}

/** The default permission a repository can have in an Organization. */
export enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = "ADMIN",
  /** No default permission value. */
  None = "NONE",
  /** Can read and clone repositories. */
  Read = "READ",
  /** Can read, clone and push to repositories. */
  Write = "WRITE",
}

/** The permissions available to members on an Organization. */
export enum OrgUpdateMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = "ADMIN",
  /** Can read and clone repositories. */
  Read = "READ",
}

/** The permissions available for repository creation on an Organization. */
export enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  /** All organization members are restricted from creating any repositories. */
  All = "ALL",
  /** All organization members are restricted from creating internal repositories. */
  Internal = "INTERNAL",
  /** All organization members are allowed to create any repositories. */
  None = "NONE",
  /** All organization members are restricted from creating private repositories. */
  Private = "PRIVATE",
  /** All organization members are restricted from creating private or internal repositories. */
  PrivateInternal = "PRIVATE_INTERNAL",
  /** All organization members are restricted from creating public repositories. */
  Public = "PUBLIC",
  /** All organization members are restricted from creating public or internal repositories. */
  PublicInternal = "PUBLIC_INTERNAL",
  /** All organization members are restricted from creating public or private repositories. */
  PublicPrivate = "PUBLIC_PRIVATE",
}

/** The possible organization invitation roles. */
export enum OrganizationInvitationRole {
  /** The user is invited to be an admin of the organization. */
  Admin = "ADMIN",
  /** The user is invited to be a billing manager of the organization. */
  BillingManager = "BILLING_MANAGER",
  /** The user is invited to be a direct member of the organization. */
  DirectMember = "DIRECT_MEMBER",
  /** The user's previous role will be reinstated. */
  Reinstate = "REINSTATE",
}

/** The possible organization invitation types. */
export enum OrganizationInvitationType {
  /** The invitation was to an email address. */
  Email = "EMAIL",
  /** The invitation was to an existing user. */
  User = "USER",
}

/** The possible roles within an organization for its members. */
export enum OrganizationMemberRole {
  /** The user is an administrator of the organization. */
  Admin = "ADMIN",
  /** The user is a member of the organization. */
  Member = "MEMBER",
}

/** The possible values for the members can create repositories setting on an organization. */
export enum OrganizationMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = "ALL",
  /** Members will not be able to create public or private repositories. */
  Disabled = "DISABLED",
  /** Members will be able to create only internal repositories. */
  Internal = "INTERNAL",
  /** Members will be able to create only private repositories. */
  Private = "PRIVATE",
}

/** Ordering options for organization connections. */
export type OrganizationOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order organizations by. */
  readonly field: OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export enum OrganizationOrderField {
  /** Order organizations by creation time */
  CreatedAt = "CREATED_AT",
  /** Order organizations by login */
  Login = "LOGIN",
}

/** Ways in which lists of package files can be ordered upon return. */
export type PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  readonly direction: Maybe<OrderDirection>;
  /** The field in which to order package files by. */
  readonly field: Maybe<PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export enum PackageFileOrderField {
  /** Order package files by creation time */
  CreatedAt = "CREATED_AT",
}

/** Ways in which lists of packages can be ordered upon return. */
export type PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  readonly direction: Maybe<OrderDirection>;
  /** The field in which to order packages by. */
  readonly field: Maybe<PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export enum PackageOrderField {
  /** Order packages by creation time */
  CreatedAt = "CREATED_AT",
}

/** The possible types of a package. */
export enum PackageType {
  /** A debian package. */
  Debian = "DEBIAN",
  /** A docker image. */
  Docker = "DOCKER",
  /** A maven package. */
  Maven = "MAVEN",
  /** An npm package. */
  Npm = "NPM",
  /** A nuget package. */
  Nuget = "NUGET",
  /** A python package. */
  Pypi = "PYPI",
  /** A rubygems package. */
  Rubygems = "RUBYGEMS",
}

/** Ways in which lists of package versions can be ordered upon return. */
export type PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  readonly direction: Maybe<OrderDirection>;
  /** The field in which to order package versions by. */
  readonly field: Maybe<PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export enum PackageVersionOrderField {
  /** Order package versions by creation time */
  CreatedAt = "CREATED_AT",
}

/** Autogenerated input type of PinIssue */
export type PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the issue to be pinned */
  readonly issueId: Scalars["ID"];
};

/** Represents items that can be pinned to a profile page or dashboard. */
export enum PinnableItemType {
  /** A gist. */
  Gist = "GIST",
  /** An issue. */
  Issue = "ISSUE",
  /** An organization. */
  Organization = "ORGANIZATION",
  /** A project. */
  Project = "PROJECT",
  /** A pull request. */
  PullRequest = "PULL_REQUEST",
  /** A repository. */
  Repository = "REPOSITORY",
  /** A team. */
  Team = "TEAM",
  /** A user. */
  User = "USER",
}

/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
export enum PinnedDiscussionGradient {
  /** A gradient of blue to mint */
  BlueMint = "BLUE_MINT",
  /** A gradient of blue to purple */
  BluePurple = "BLUE_PURPLE",
  /** A gradient of pink to blue */
  PinkBlue = "PINK_BLUE",
  /** A gradient of purple to coral */
  PurpleCoral = "PURPLE_CORAL",
  /** A gradient of red to orange */
  RedOrange = "RED_ORANGE",
}

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
export enum PinnedDiscussionPattern {
  /** An upward-facing chevron pattern */
  ChevronUp = "CHEVRON_UP",
  /** A hollow dot pattern */
  Dot = "DOT",
  /** A solid dot pattern */
  DotFill = "DOT_FILL",
  /** A heart pattern */
  HeartFill = "HEART_FILL",
  /** A plus sign pattern */
  Plus = "PLUS",
  /** A lightning bolt pattern */
  Zap = "ZAP",
}

/** The possible archived states of a project card. */
export enum ProjectCardArchivedState {
  /** A project card that is archived */
  Archived = "ARCHIVED",
  /** A project card that is not archived */
  NotArchived = "NOT_ARCHIVED",
}

/** An issue or PR and its owning repository to be used in a project card. */
export type ProjectCardImport = {
  /** The issue or pull request number. */
  readonly number: Scalars["Int"];
  /** Repository name with owner (owner/repository). */
  readonly repository: Scalars["String"];
};

/** Various content states of a ProjectCard */
export enum ProjectCardState {
  /** The card has content only. */
  ContentOnly = "CONTENT_ONLY",
  /** The card has a note only. */
  NoteOnly = "NOTE_ONLY",
  /** The card is redacted. */
  Redacted = "REDACTED",
}

/** A project column and a list of its issues and PRs. */
export type ProjectColumnImport = {
  /** The name of the column. */
  readonly columnName: Scalars["String"];
  /** A list of issues and pull requests in the column. */
  readonly issues: Maybe<ReadonlyArray<ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  readonly position: Scalars["Int"];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export enum ProjectColumnPurpose {
  /** The column contains cards which are complete */
  Done = "DONE",
  /** The column contains cards which are currently being worked on */
  InProgress = "IN_PROGRESS",
  /** The column contains cards still to be worked on */
  Todo = "TODO",
}

/** Ways in which lists of projects can be ordered upon return. */
export type ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order projects by. */
  readonly field: ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export enum ProjectOrderField {
  /** Order projects by creation time */
  CreatedAt = "CREATED_AT",
  /** Order projects by name */
  Name = "NAME",
  /** Order projects by update time */
  UpdatedAt = "UPDATED_AT",
}

/** State of the project; either 'open' or 'closed' */
export enum ProjectState {
  /** The project is closed. */
  Closed = "CLOSED",
  /** The project is open. */
  Open = "OPEN",
}

/** GitHub-provided templates for Projects */
export enum ProjectTemplate {
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  AutomatedKanbanV2 = "AUTOMATED_KANBAN_V2",
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  AutomatedReviewsKanban = "AUTOMATED_REVIEWS_KANBAN",
  /** Create a board with columns for To do, In progress and Done. */
  BasicKanban = "BASIC_KANBAN",
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  BugTriage = "BUG_TRIAGE",
}

/** Represents available types of methods to use when merging a pull request. */
export enum PullRequestMergeMethod {
  /** Add all commits from the head branch to the base branch with a merge commit. */
  Merge = "MERGE",
  /** Add all commits from the head branch onto the base branch individually. */
  Rebase = "REBASE",
  /** Combine all commits from the head branch into a single commit in the base branch. */
  Squash = "SQUASH",
}

/** Ways in which lists of issues can be ordered upon return. */
export type PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order pull requests by. */
  readonly field: PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export enum PullRequestOrderField {
  /** Order pull_requests by creation time */
  CreatedAt = "CREATED_AT",
  /** Order pull_requests by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The possible states of a pull request review comment. */
export enum PullRequestReviewCommentState {
  /** A comment that is part of a pending review */
  Pending = "PENDING",
  /** A comment that is part of a submitted review */
  Submitted = "SUBMITTED",
}

/** The review status of a pull request. */
export enum PullRequestReviewDecision {
  /** The pull request has received an approving review. */
  Approved = "APPROVED",
  /** Changes have been requested on the pull request. */
  ChangesRequested = "CHANGES_REQUESTED",
  /** A review is required before the pull request can be merged. */
  ReviewRequired = "REVIEW_REQUIRED",
}

/** The possible events to perform on a pull request review. */
export enum PullRequestReviewEvent {
  /** Submit feedback and approve merging these changes. */
  Approve = "APPROVE",
  /** Submit general feedback without explicit approval. */
  Comment = "COMMENT",
  /** Dismiss review so it now longer effects merging. */
  Dismiss = "DISMISS",
  /** Submit feedback that must be addressed before merging. */
  RequestChanges = "REQUEST_CHANGES",
}

/** The possible states of a pull request review. */
export enum PullRequestReviewState {
  /** A review allowing the pull request to merge. */
  Approved = "APPROVED",
  /** A review blocking the pull request from merging. */
  ChangesRequested = "CHANGES_REQUESTED",
  /** An informational review. */
  Commented = "COMMENTED",
  /** A review that has been dismissed. */
  Dismissed = "DISMISSED",
  /** A review that has not yet been submitted. */
  Pending = "PENDING",
}

/** The possible states of a pull request. */
export enum PullRequestState {
  /** A pull request that has been closed without being merged. */
  Closed = "CLOSED",
  /** A pull request that has been closed by being merged. */
  Merged = "MERGED",
  /** A pull request that is still open. */
  Open = "OPEN",
}

/** The possible item types found in a timeline. */
export enum PullRequestTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = "ADDED_TO_PROJECT_EVENT",
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = "ASSIGNED_EVENT",
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  AutomaticBaseChangeFailedEvent = "AUTOMATIC_BASE_CHANGE_FAILED_EVENT",
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  AutomaticBaseChangeSucceededEvent = "AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT",
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  AutoMergeDisabledEvent = "AUTO_MERGE_DISABLED_EVENT",
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  AutoMergeEnabledEvent = "AUTO_MERGE_ENABLED_EVENT",
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  AutoRebaseEnabledEvent = "AUTO_REBASE_ENABLED_EVENT",
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  AutoSquashEnabledEvent = "AUTO_SQUASH_ENABLED_EVENT",
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  BaseRefChangedEvent = "BASE_REF_CHANGED_EVENT",
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  BaseRefDeletedEvent = "BASE_REF_DELETED_EVENT",
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  BaseRefForcePushedEvent = "BASE_REF_FORCE_PUSHED_EVENT",
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = "CLOSED_EVENT",
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = "COMMENT_DELETED_EVENT",
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = "CONNECTED_EVENT",
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  /** Represents a 'convert_to_draft' event on a given pull request. */
  ConvertToDraftEvent = "CONVERT_TO_DRAFT_EVENT",
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = "CROSS_REFERENCED_EVENT",
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = "DEMILESTONED_EVENT",
  /** Represents a 'deployed' event on a given pull request. */
  DeployedEvent = "DEPLOYED_EVENT",
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  DeploymentEnvironmentChangedEvent = "DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT",
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = "DISCONNECTED_EVENT",
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  HeadRefDeletedEvent = "HEAD_REF_DELETED_EVENT",
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  HeadRefForcePushedEvent = "HEAD_REF_FORCE_PUSHED_EVENT",
  /** Represents a 'head_ref_restored' event on a given pull request. */
  HeadRefRestoredEvent = "HEAD_REF_RESTORED_EVENT",
  /** Represents a comment on an Issue. */
  IssueComment = "ISSUE_COMMENT",
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = "LABELED_EVENT",
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = "LOCKED_EVENT",
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = "MARKED_AS_DUPLICATE_EVENT",
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = "MENTIONED_EVENT",
  /** Represents a 'merged' event on a given pull request. */
  MergedEvent = "MERGED_EVENT",
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = "MILESTONED_EVENT",
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = "PINNED_EVENT",
  /** Represents a Git commit part of a pull request. */
  PullRequestCommit = "PULL_REQUEST_COMMIT",
  /** Represents a commit comment thread part of a pull request. */
  PullRequestCommitCommentThread = "PULL_REQUEST_COMMIT_COMMENT_THREAD",
  /** A review object for a given pull request. */
  PullRequestReview = "PULL_REQUEST_REVIEW",
  /** A threaded list of comments for a given pull request. */
  PullRequestReviewThread = "PULL_REQUEST_REVIEW_THREAD",
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  PullRequestRevisionMarker = "PULL_REQUEST_REVISION_MARKER",
  /** Represents a 'ready_for_review' event on a given pull request. */
  ReadyForReviewEvent = "READY_FOR_REVIEW_EVENT",
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = "REFERENCED_EVENT",
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = "REMOVED_FROM_PROJECT_EVENT",
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = "RENAMED_TITLE_EVENT",
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = "REOPENED_EVENT",
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ReviewDismissedEvent = "REVIEW_DISMISSED_EVENT",
  /** Represents an 'review_requested' event on a given pull request. */
  ReviewRequestedEvent = "REVIEW_REQUESTED_EVENT",
  /** Represents an 'review_request_removed' event on a given pull request. */
  ReviewRequestRemovedEvent = "REVIEW_REQUEST_REMOVED_EVENT",
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = "SUBSCRIBED_EVENT",
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = "TRANSFERRED_EVENT",
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = "UNASSIGNED_EVENT",
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = "UNLABELED_EVENT",
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = "UNLOCKED_EVENT",
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = "UNMARKED_AS_DUPLICATE_EVENT",
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = "UNPINNED_EVENT",
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = "UNSUBSCRIBED_EVENT",
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = "USER_BLOCKED_EVENT",
}

/** The possible target states when updating a pull request. */
export enum PullRequestUpdateState {
  /** A pull request that has been closed without being merged. */
  Closed = "CLOSED",
  /** A pull request that is still open. */
  Open = "OPEN",
}

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export enum ReactionContent {
  /** Represents the `:confused:` emoji. */
  Confused = "CONFUSED",
  /** Represents the `:eyes:` emoji. */
  Eyes = "EYES",
  /** Represents the `:heart:` emoji. */
  Heart = "HEART",
  /** Represents the `:hooray:` emoji. */
  Hooray = "HOORAY",
  /** Represents the `:laugh:` emoji. */
  Laugh = "LAUGH",
  /** Represents the `:rocket:` emoji. */
  Rocket = "ROCKET",
  /** Represents the `:-1:` emoji. */
  ThumbsDown = "THUMBS_DOWN",
  /** Represents the `:+1:` emoji. */
  ThumbsUp = "THUMBS_UP",
}

/** Ways in which lists of reactions can be ordered upon return. */
export type ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order reactions by. */
  readonly field: ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export enum ReactionOrderField {
  /** Allows ordering a list of reactions by when they were created. */
  CreatedAt = "CREATED_AT",
}

/** Ways in which lists of git refs can be ordered upon return. */
export type RefOrder = {
  /** The direction in which to order refs by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order refs by. */
  readonly field: RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export enum RefOrderField {
  /** Order refs by their alphanumeric name */
  Alphabetical = "ALPHABETICAL",
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  TagCommitDate = "TAG_COMMIT_DATE",
}

/** A ref update */
export type RefUpdate = {
  /** The value this ref should be updated to. */
  readonly afterOid: Scalars["GitObjectID"];
  /** The value this ref needs to point to before the update. */
  readonly beforeOid: Maybe<Scalars["GitObjectID"]>;
  /** Force a non fast-forward update. */
  readonly force: Maybe<Scalars["Boolean"]>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  readonly name: Scalars["GitRefname"];
};

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set an identity provider. */
  readonly enterpriseId: Scalars["ID"];
};

/** Autogenerated input type of RegenerateVerifiableDomainToken */
export type RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of RejectDeployments */
export type RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Optional comment for rejecting deployments */
  readonly comment: Maybe<Scalars["String"]>;
  /** The ids of environments to reject deployments */
  readonly environmentIds: ReadonlyArray<Scalars["ID"]>;
  /** The node ID of the workflow run containing the pending deployments. */
  readonly workflowRunId: Scalars["ID"];
};

/** Ways in which lists of releases can be ordered upon return. */
export type ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order releases by. */
  readonly field: ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export enum ReleaseOrderField {
  /** Order releases by creation time */
  CreatedAt = "CREATED_AT",
  /** Order releases alphabetically by name */
  Name = "NAME",
}

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  readonly assignableId: Scalars["ID"];
  /** The id of users to remove as assignees. */
  readonly assigneeIds: ReadonlyArray<Scalars["ID"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Enterprise ID from which to remove the administrator. */
  readonly enterpriseId: Scalars["ID"];
  /** The login of the user to remove as an administrator. */
  readonly login: Scalars["String"];
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise from which to remove the identity provider. */
  readonly enterpriseId: Scalars["ID"];
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise from which the organization should be removed. */
  readonly enterpriseId: Scalars["ID"];
  /** The ID of the organization to remove from the enterprise. */
  readonly organizationId: Scalars["ID"];
};

/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
export type RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the Enterprise which the admin belongs to. */
  readonly enterpriseId: Scalars["ID"];
  /** The login of a member who will lose the support entitlement. */
  readonly login: Scalars["String"];
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ids of labels to remove. */
  readonly labelIds: ReadonlyArray<Scalars["ID"]>;
  /** The id of the Labelable to remove labels from. */
  readonly labelableId: Scalars["ID"];
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the organization to remove the outside collaborator from. */
  readonly organizationId: Scalars["ID"];
  /** The ID of the outside collaborator to remove. */
  readonly userId: Scalars["ID"];
};

/** Autogenerated input type of RemoveReaction */
export type RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of the emoji reaction to remove. */
  readonly content: ReactionContent;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars["ID"];
};

/** Autogenerated input type of RemoveStar */
export type RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Starrable ID to unstar. */
  readonly starrableId: Scalars["ID"];
};

/** Autogenerated input type of RemoveUpvote */
export type RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the discussion or comment to remove upvote. */
  readonly subjectId: Scalars["ID"];
};

/** Autogenerated input type of ReopenIssue */
export type ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the issue to be opened. */
  readonly issueId: Scalars["ID"];
};

/** Autogenerated input type of ReopenPullRequest */
export type ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the pull request to be reopened. */
  readonly pullRequestId: Scalars["ID"];
};

/** The privacy of a repository */
export enum RepoAccessAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** The privacy of a repository */
export enum RepoAddMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** The privacy of a repository */
export enum RepoArchivedAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** The merge options available for pull requests to this repository. */
export enum RepoChangeMergeSettingAuditEntryMergeType {
  /** The pull request is added to the base branch in a merge commit. */
  Merge = "MERGE",
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  Rebase = "REBASE",
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  Squash = "SQUASH",
}

/** The privacy of a repository */
export enum RepoCreateAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** The privacy of a repository */
export enum RepoDestroyAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** The privacy of a repository */
export enum RepoRemoveMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** The reasons a piece of content can be reported or minimized. */
export enum ReportedContentClassifiers {
  /** An abusive or harassing piece of content */
  Abuse = "ABUSE",
  /** A duplicated piece of content */
  Duplicate = "DUPLICATE",
  /** An irrelevant piece of content */
  OffTopic = "OFF_TOPIC",
  /** An outdated piece of content */
  Outdated = "OUTDATED",
  /** The content has been resolved */
  Resolved = "RESOLVED",
  /** A spammy piece of content */
  Spam = "SPAM",
}

/** The affiliation of a user to a repository */
export enum RepositoryAffiliation {
  /** Repositories that the user has been added to as a collaborator. */
  Collaborator = "COLLABORATOR",
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  OrganizationMember = "ORGANIZATION_MEMBER",
  /** Repositories that are owned by the authenticated user. */
  Owner = "OWNER",
}

/** The reason a repository is listed as 'contributed'. */
export enum RepositoryContributionType {
  /** Created a commit */
  Commit = "COMMIT",
  /** Created an issue */
  Issue = "ISSUE",
  /** Created a pull request */
  PullRequest = "PULL_REQUEST",
  /** Reviewed a pull request */
  PullRequestReview = "PULL_REQUEST_REVIEW",
  /** Created the repository */
  Repository = "REPOSITORY",
}

/** A repository interaction limit. */
export enum RepositoryInteractionLimit {
  /** Users that are not collaborators will not be able to interact with the repository. */
  CollaboratorsOnly = "COLLABORATORS_ONLY",
  /** Users that have not previously committed to a repositorys default branch will be unable to interact with the repository. */
  ContributorsOnly = "CONTRIBUTORS_ONLY",
  /** Users that have recently created their account will be unable to interact with the repository. */
  ExistingUsers = "EXISTING_USERS",
  /** No interaction limits are enabled. */
  NoLimit = "NO_LIMIT",
}

/** The length for a repository interaction limit to be enabled for. */
export enum RepositoryInteractionLimitExpiry {
  /** The interaction limit will expire after 1 day. */
  OneDay = "ONE_DAY",
  /** The interaction limit will expire after 1 month. */
  OneMonth = "ONE_MONTH",
  /** The interaction limit will expire after 1 week. */
  OneWeek = "ONE_WEEK",
  /** The interaction limit will expire after 6 months. */
  SixMonths = "SIX_MONTHS",
  /** The interaction limit will expire after 3 days. */
  ThreeDays = "THREE_DAYS",
}

/** Indicates where an interaction limit is configured. */
export enum RepositoryInteractionLimitOrigin {
  /** A limit that is configured at the organization level. */
  Organization = "ORGANIZATION",
  /** A limit that is configured at the repository level. */
  Repository = "REPOSITORY",
  /** A limit that is configured at the user-wide level. */
  User = "USER",
}

/** Ordering options for repository invitation connections. */
export type RepositoryInvitationOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order repository invitations by. */
  readonly field: RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export enum RepositoryInvitationOrderField {
  /** Order repository invitations by creation time */
  CreatedAt = "CREATED_AT",
  /** Order repository invitations by invitee login */
  InviteeLogin = "INVITEE_LOGIN",
}

/** The possible reasons a given repository could be in a locked state. */
export enum RepositoryLockReason {
  /** The repository is locked due to a billing related reason. */
  Billing = "BILLING",
  /** The repository is locked due to a migration. */
  Migrating = "MIGRATING",
  /** The repository is locked due to a move. */
  Moving = "MOVING",
  /** The repository is locked due to a rename. */
  Rename = "RENAME",
}

/** Ordering options for repository connections */
export type RepositoryOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order repositories by. */
  readonly field: RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export enum RepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = "CREATED_AT",
  /** Order repositories by name */
  Name = "NAME",
  /** Order repositories by push time */
  PushedAt = "PUSHED_AT",
  /** Order repositories by number of stargazers */
  Stargazers = "STARGAZERS",
  /** Order repositories by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The access level to a repository */
export enum RepositoryPermission {
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  Admin = "ADMIN",
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  Maintain = "MAINTAIN",
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  Read = "READ",
  /** Can read and clone this repository. Can also manage issues and pull requests */
  Triage = "TRIAGE",
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  Write = "WRITE",
}

/** The privacy of a repository */
export enum RepositoryPrivacy {
  /** Private */
  Private = "PRIVATE",
  /** Public */
  Public = "PUBLIC",
}

/** The repository's visibility level. */
export enum RepositoryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** Autogenerated input type of RequestReviews */
export type RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the pull request to modify. */
  readonly pullRequestId: Scalars["ID"];
  /** The Node IDs of the team to request. */
  readonly teamIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** Add users to the set rather than replace. */
  readonly union: Maybe<Scalars["Boolean"]>;
  /** The Node IDs of the user to request. */
  readonly userIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
};

/** The possible states that can be requested when creating a check run. */
export enum RequestableCheckStatusState {
  /** The check suite or run has been completed. */
  Completed = "COMPLETED",
  /** The check suite or run is in progress. */
  InProgress = "IN_PROGRESS",
  /** The check suite or run is in pending state. */
  Pending = "PENDING",
  /** The check suite or run has been queued. */
  Queued = "QUEUED",
  /** The check suite or run is in waiting state. */
  Waiting = "WAITING",
}

/** Autogenerated input type of RerequestCheckSuite */
export type RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  readonly checkSuiteId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of ResolveReviewThread */
export type ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the thread to resolve */
  readonly threadId: Scalars["ID"];
};

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export enum SamlDigestAlgorithm {
  /** SHA1 */
  Sha1 = "SHA1",
  /** SHA256 */
  Sha256 = "SHA256",
  /** SHA384 */
  Sha384 = "SHA384",
  /** SHA512 */
  Sha512 = "SHA512",
}

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export enum SamlSignatureAlgorithm {
  /** RSA-SHA1 */
  RsaSha1 = "RSA_SHA1",
  /** RSA-SHA256 */
  RsaSha256 = "RSA_SHA256",
  /** RSA-SHA384 */
  RsaSha384 = "RSA_SHA384",
  /** RSA-SHA512 */
  RsaSha512 = "RSA_SHA512",
}

/** Ordering options for saved reply connections. */
export type SavedReplyOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order saved replies by. */
  readonly field: SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export enum SavedReplyOrderField {
  /** Order saved reply by when they were updated. */
  UpdatedAt = "UPDATED_AT",
}

/** Represents the individual results of a search. */
export enum SearchType {
  /** Returns matching discussions in repositories. */
  Discussion = "DISCUSSION",
  /** Returns results matching issues in repositories. */
  Issue = "ISSUE",
  /** Returns results matching repositories. */
  Repository = "REPOSITORY",
  /** Returns results matching users and organizations on GitHub. */
  User = "USER",
}

/** The possible ecosystems of a security vulnerability's package. */
export enum SecurityAdvisoryEcosystem {
  /** PHP packages hosted at packagist.org */
  Composer = "COMPOSER",
  /** Go modules */
  Go = "GO",
  /** Java artifacts hosted at the Maven central repository */
  Maven = "MAVEN",
  /** JavaScript packages hosted at npmjs.com */
  Npm = "NPM",
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = "NUGET",
  /** Python packages hosted at PyPI.org */
  Pip = "PIP",
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = "RUBYGEMS",
  /** Rust crates */
  Rust = "RUST",
}

/** An advisory identifier to filter results on. */
export type SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  readonly type: SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  readonly value: Scalars["String"];
};

/** Identifier formats available for advisories. */
export enum SecurityAdvisoryIdentifierType {
  /** Common Vulnerabilities and Exposures Identifier. */
  Cve = "CVE",
  /** GitHub Security Advisory ID. */
  Ghsa = "GHSA",
}

/** Ordering options for security advisory connections */
export type SecurityAdvisoryOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order security advisories by. */
  readonly field: SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export enum SecurityAdvisoryOrderField {
  /** Order advisories by publication time */
  PublishedAt = "PUBLISHED_AT",
  /** Order advisories by update time */
  UpdatedAt = "UPDATED_AT",
}

/** Severity of the vulnerability. */
export enum SecurityAdvisorySeverity {
  /** Critical. */
  Critical = "CRITICAL",
  /** High. */
  High = "HIGH",
  /** Low. */
  Low = "LOW",
  /** Moderate. */
  Moderate = "MODERATE",
}

/** Ordering options for security vulnerability connections */
export type SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order security vulnerabilities by. */
  readonly field: SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export enum SecurityVulnerabilityOrderField {
  /** Order vulnerability by update time */
  UpdatedAt = "UPDATED_AT",
}

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  readonly digestMethod: SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  readonly enterpriseId: Scalars["ID"];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  readonly idpCertificate: Scalars["String"];
  /** The Issuer Entity ID for the SAML identity provider */
  readonly issuer: Maybe<Scalars["String"]>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  readonly signatureMethod: SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  readonly ssoUrl: Scalars["URI"];
};

/** Autogenerated input type of SetOrganizationInteractionLimit */
export type SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** When this limit should expire. */
  readonly expiry: Maybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  readonly limit: RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  readonly organizationId: Scalars["ID"];
};

/** Autogenerated input type of SetRepositoryInteractionLimit */
export type SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** When this limit should expire. */
  readonly expiry: Maybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  readonly limit: RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of SetUserInteractionLimit */
export type SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** When this limit should expire. */
  readonly expiry: Maybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  readonly limit: RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  readonly userId: Scalars["ID"];
};

/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
export type SponsorOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order sponsor entities by. */
  readonly field: SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
export enum SponsorOrderField {
  /** Order sponsorable entities by login (username). */
  Login = "LOGIN",
  /** Order sponsors by their relevance to the viewer. */
  Relevance = "RELEVANCE",
}

/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
export type SponsorableOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order sponsorable entities by. */
  readonly field: SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
export enum SponsorableOrderField {
  /** Order sponsorable entities by login (username). */
  Login = "LOGIN",
}

/** The possible actions that GitHub Sponsors activities can represent. */
export enum SponsorsActivityAction {
  /** The activity was cancelling a sponsorship. */
  CancelledSponsorship = "CANCELLED_SPONSORSHIP",
  /** The activity was starting a sponsorship. */
  NewSponsorship = "NEW_SPONSORSHIP",
  /** The activity was scheduling a downgrade or cancellation. */
  PendingChange = "PENDING_CHANGE",
  /** The activity was funds being refunded to the sponsor or GitHub. */
  Refund = "REFUND",
  /** The activity was disabling matching for a previously matched sponsorship. */
  SponsorMatchDisabled = "SPONSOR_MATCH_DISABLED",
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  TierChange = "TIER_CHANGE",
}

/** Ordering options for GitHub Sponsors activity connections. */
export type SponsorsActivityOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order activity by. */
  readonly field: SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
export enum SponsorsActivityOrderField {
  /** Order activities by when they happened. */
  Timestamp = "TIMESTAMP",
}

/** The possible time periods for which Sponsors activities can be requested. */
export enum SponsorsActivityPeriod {
  /** Don't restrict the activity to any date range, include all activity. */
  All = "ALL",
  /** The previous calendar day. */
  Day = "DAY",
  /** The previous thirty days. */
  Month = "MONTH",
  /** The previous seven days. */
  Week = "WEEK",
}

/** The different kinds of goals a GitHub Sponsors member can have. */
export enum SponsorsGoalKind {
  /** The goal is about getting a certain amount in USD from sponsorships each month. */
  MonthlySponsorshipAmount = "MONTHLY_SPONSORSHIP_AMOUNT",
  /** The goal is about reaching a certain number of sponsors. */
  TotalSponsorsCount = "TOTAL_SPONSORS_COUNT",
}

/** Ordering options for Sponsors tiers connections. */
export type SponsorsTierOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order tiers by. */
  readonly field: SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export enum SponsorsTierOrderField {
  /** Order tiers by creation time. */
  CreatedAt = "CREATED_AT",
  /** Order tiers by their monthly price in cents */
  MonthlyPriceInCents = "MONTHLY_PRICE_IN_CENTS",
}

/** Ordering options for sponsorship newsletter connections. */
export type SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order sponsorship newsletters by. */
  readonly field: SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
export enum SponsorshipNewsletterOrderField {
  /** Order sponsorship newsletters by when they were created. */
  CreatedAt = "CREATED_AT",
}

/** Ordering options for sponsorship connections. */
export type SponsorshipOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order sponsorship by. */
  readonly field: SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export enum SponsorshipOrderField {
  /** Order sponsorship by creation time. */
  CreatedAt = "CREATED_AT",
}

/** The privacy of a sponsorship */
export enum SponsorshipPrivacy {
  /** Private */
  Private = "PRIVATE",
  /** Public */
  Public = "PUBLIC",
}

/** Ways in which star connections can be ordered. */
export type StarOrder = {
  /** The direction in which to order nodes. */
  readonly direction: OrderDirection;
  /** The field in which to order nodes by. */
  readonly field: StarOrderField;
};

/** Properties by which star connections can be ordered. */
export enum StarOrderField {
  /** Allows ordering a list of stars by when they were created. */
  StarredAt = "STARRED_AT",
}

/** The possible commit status states. */
export enum StatusState {
  /** Status is errored. */
  Error = "ERROR",
  /** Status is expected. */
  Expected = "EXPECTED",
  /** Status is failing. */
  Failure = "FAILURE",
  /** Status is pending. */
  Pending = "PENDING",
  /** Status is successful. */
  Success = "SUCCESS",
}

/** Autogenerated input type of SubmitPullRequestReview */
export type SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The event to send to the Pull Request Review. */
  readonly event: PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  readonly pullRequestId: Maybe<Scalars["ID"]>;
  /** The Pull Request Review ID to submit. */
  readonly pullRequestReviewId: Maybe<Scalars["ID"]>;
};

/** The possible states of a subscription. */
export enum SubscriptionState {
  /** The User is never notified. */
  Ignored = "IGNORED",
  /** The User is notified of all conversations. */
  Subscribed = "SUBSCRIBED",
  /** The User is only notified when participating or @mentioned. */
  Unsubscribed = "UNSUBSCRIBED",
}

/** Ways in which team discussion comment connections can be ordered. */
export type TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  readonly direction: OrderDirection;
  /** The field by which to order nodes. */
  readonly field: TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export enum TeamDiscussionCommentOrderField {
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  Number = "NUMBER",
}

/** Ways in which team discussion connections can be ordered. */
export type TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  readonly direction: OrderDirection;
  /** The field by which to order nodes. */
  readonly field: TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export enum TeamDiscussionOrderField {
  /** Allows chronological ordering of team discussions. */
  CreatedAt = "CREATED_AT",
}

/** Ordering options for team member connections */
export type TeamMemberOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order team members by. */
  readonly field: TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export enum TeamMemberOrderField {
  /** Order team members by creation time */
  CreatedAt = "CREATED_AT",
  /** Order team members by login */
  Login = "LOGIN",
}

/** The possible team member roles; either 'maintainer' or 'member'. */
export enum TeamMemberRole {
  /** A team maintainer has permission to add and remove team members. */
  Maintainer = "MAINTAINER",
  /** A team member has no administrative permissions on the team. */
  Member = "MEMBER",
}

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export enum TeamMembershipType {
  /** Includes immediate and child team members for the team. */
  All = "ALL",
  /** Includes only child team members for the team. */
  ChildTeam = "CHILD_TEAM",
  /** Includes only immediate members of the team. */
  Immediate = "IMMEDIATE",
}

/** Ways in which team connections can be ordered. */
export type TeamOrder = {
  /** The direction in which to order nodes. */
  readonly direction: OrderDirection;
  /** The field in which to order nodes by. */
  readonly field: TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export enum TeamOrderField {
  /** Allows ordering a list of teams by name. */
  Name = "NAME",
}

/** The possible team privacy values. */
export enum TeamPrivacy {
  /** A secret team can only be seen by its members. */
  Secret = "SECRET",
  /** A visible team can be seen and @mentioned by every member of the organization. */
  Visible = "VISIBLE",
}

/** Ordering options for team repository connections */
export type TeamRepositoryOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order repositories by. */
  readonly field: TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export enum TeamRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = "CREATED_AT",
  /** Order repositories by name */
  Name = "NAME",
  /** Order repositories by permission */
  Permission = "PERMISSION",
  /** Order repositories by push time */
  PushedAt = "PUSHED_AT",
  /** Order repositories by number of stargazers */
  Stargazers = "STARGAZERS",
  /** Order repositories by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The possible team review assignment algorithms */
export enum TeamReviewAssignmentAlgorithm {
  /** Balance review load across the entire team */
  LoadBalance = "LOAD_BALANCE",
  /** Alternate reviews between each team member */
  RoundRobin = "ROUND_ROBIN",
}

/** The role of a user on a team. */
export enum TeamRole {
  /** User has admin rights on the team. */
  Admin = "ADMIN",
  /** User is a member of the team. */
  Member = "MEMBER",
}

/** Reason that the suggested topic is declined. */
export enum TopicSuggestionDeclineReason {
  /** The suggested topic is not relevant to the repository. */
  NotRelevant = "NOT_RELEVANT",
  /** The viewer does not like the suggested topic. */
  PersonalPreference = "PERSONAL_PREFERENCE",
  /** The suggested topic is too general for the repository. */
  TooGeneral = "TOO_GENERAL",
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  TooSpecific = "TOO_SPECIFIC",
}

/** Autogenerated input type of TransferIssue */
export type TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the issue to be transferred */
  readonly issueId: Scalars["ID"];
  /** The Node ID of the repository the issue should be transferred to */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of UnarchiveRepository */
export type UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the repository to unarchive. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of UnfollowUser */
export type UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the user to unfollow. */
  readonly userId: Scalars["ID"];
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the Project linked to the Repository. */
  readonly projectId: Scalars["ID"];
  /** The ID of the Repository linked to the Project. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of UnlockLockable */
export type UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the item to be unlocked. */
  readonly lockableId: Scalars["ID"];
};

/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
export type UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of UnmarkFileAsViewed */
export type UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The path of the file to mark as unviewed */
  readonly path: Scalars["String"];
  /** The Node ID of the pull request. */
  readonly pullRequestId: Scalars["ID"];
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  readonly canonicalId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  readonly duplicateId: Scalars["ID"];
};

/** Autogenerated input type of UnminimizeComment */
export type UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars["ID"];
};

/** Autogenerated input type of UnpinIssue */
export type UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the issue to be unpinned */
  readonly issueId: Scalars["ID"];
};

/** Autogenerated input type of UnresolveReviewThread */
export type UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the thread to unresolve */
  readonly threadId: Scalars["ID"];
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  readonly allowsDeletions: Maybe<Scalars["Boolean"]>;
  /** Are force pushes allowed on this branch. */
  readonly allowsForcePushes: Maybe<Scalars["Boolean"]>;
  /** The global relay id of the branch protection rule to be updated. */
  readonly branchProtectionRuleId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  readonly dismissesStaleReviews: Maybe<Scalars["Boolean"]>;
  /** Can admins overwrite branch protection. */
  readonly isAdminEnforced: Maybe<Scalars["Boolean"]>;
  /** The glob-like pattern used to determine matching branches. */
  readonly pattern: Maybe<Scalars["String"]>;
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  readonly pushActorIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** Number of approving reviews required to update matching branches. */
  readonly requiredApprovingReviewCount: Maybe<Scalars["Int"]>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  readonly requiredStatusCheckContexts: Maybe<ReadonlyArray<Scalars["String"]>>;
  /** Are approving reviews required to update matching branches. */
  readonly requiresApprovingReviews: Maybe<Scalars["Boolean"]>;
  /** Are reviews from code owners required to update matching branches. */
  readonly requiresCodeOwnerReviews: Maybe<Scalars["Boolean"]>;
  /** Are commits required to be signed. */
  readonly requiresCommitSignatures: Maybe<Scalars["Boolean"]>;
  /** Are conversations required to be resolved before merging. */
  readonly requiresConversationResolution: Maybe<Scalars["Boolean"]>;
  /** Are merge commits prohibited from being pushed to this branch. */
  readonly requiresLinearHistory: Maybe<Scalars["Boolean"]>;
  /** Are status checks required to update matching branches. */
  readonly requiresStatusChecks: Maybe<Scalars["Boolean"]>;
  /** Are branches required to be up to date before merging. */
  readonly requiresStrictStatusChecks: Maybe<Scalars["Boolean"]>;
  /** Is pushing to matching branches restricted. */
  readonly restrictsPushes: Maybe<Scalars["Boolean"]>;
  /** Is dismissal of pull request reviews restricted. */
  readonly restrictsReviewDismissals: Maybe<Scalars["Boolean"]>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  readonly reviewDismissalActorIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
};

/** Autogenerated input type of UpdateCheckRun */
export type UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  readonly actions: Maybe<ReadonlyArray<CheckRunAction>>;
  /** The node of the check. */
  readonly checkRunId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The time that the check run finished. */
  readonly completedAt: Maybe<Scalars["DateTime"]>;
  /** The final conclusion of the check. */
  readonly conclusion: Maybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  readonly detailsUrl: Maybe<Scalars["URI"]>;
  /** A reference for the run on the integrator's system. */
  readonly externalId: Maybe<Scalars["String"]>;
  /** The name of the check. */
  readonly name: Maybe<Scalars["String"]>;
  /** Descriptive details about the run. */
  readonly output: Maybe<CheckRunOutput>;
  /** The node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
  /** The time that the check run began. */
  readonly startedAt: Maybe<Scalars["DateTime"]>;
  /** The current status. */
  readonly status: Maybe<RequestableCheckStatusState>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
export type UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  readonly autoTriggerPreferences: ReadonlyArray<CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of UpdateDiscussionComment */
export type UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the discussion comment to update. */
  readonly commentId: Scalars["ID"];
};

/** Autogenerated input type of UpdateDiscussion */
export type UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  readonly body: Maybe<Scalars["String"]>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  readonly categoryId: Maybe<Scalars["ID"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the discussion to update. */
  readonly discussionId: Scalars["ID"];
  /** The new discussion title. */
  readonly title: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the Enterprise which the admin belongs to. */
  readonly enterpriseId: Scalars["ID"];
  /** The login of a administrator whose role is being changed. */
  readonly login: Scalars["String"];
  /** The new role for the Enterprise administrator. */
  readonly role: EnterpriseAdministratorRole;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the allow private repository forking setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the base repository permission setting on the enterprise. */
  readonly settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the members can change repository visibility setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  readonly enterpriseId: Scalars["ID"];
  /** Allow members to create internal repositories. Defaults to current value. */
  readonly membersCanCreateInternalRepositories: Maybe<Scalars["Boolean"]>;
  /** Allow members to create private repositories. Defaults to current value. */
  readonly membersCanCreatePrivateRepositories: Maybe<Scalars["Boolean"]>;
  /** Allow members to create public repositories. Defaults to current value. */
  readonly membersCanCreatePublicRepositories: Maybe<Scalars["Boolean"]>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  readonly membersCanCreateRepositoriesPolicyEnabled: Maybe<Scalars["Boolean"]>;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  readonly settingValue: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the members can delete issues setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the members can delete repositories setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the members can invite collaborators setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the members can make purchases setting on the enterprise. */
  readonly settingValue: EnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the members can update protected branches setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the members can view dependency insights setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the organization projects setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The description of the enterprise. */
  readonly description: Maybe<Scalars["String"]>;
  /** The Enterprise ID to update. */
  readonly enterpriseId: Scalars["ID"];
  /** The location of the enterprise. */
  readonly location: Maybe<Scalars["String"]>;
  /** The name of the enterprise. */
  readonly name: Maybe<Scalars["String"]>;
  /** The URL of the enterprise's website. */
  readonly websiteUrl: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the repository projects setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the team discussions setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  readonly enterpriseId: Scalars["ID"];
  /** The value for the two factor authentication required setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledSettingValue;
};

/** Autogenerated input type of UpdateEnvironment */
export type UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The node ID of the environment. */
  readonly environmentId: Scalars["ID"];
  /** The ids of users or teams that can approve deployments to this environment */
  readonly reviewers: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The wait timer in minutes. */
  readonly waitTimer: Maybe<Scalars["Int"]>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  readonly ownerId: Scalars["ID"];
  /** The value for the IP allow list enabled setting. */
  readonly settingValue: IpAllowListEnabledSettingValue;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
export type UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  readonly allowListValue: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the IP allow list entry to update. */
  readonly ipAllowListEntryId: Scalars["ID"];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  readonly isActive: Scalars["Boolean"];
  /** An optional name for the IP allow list entry. */
  readonly name: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the owner. */
  readonly ownerId: Scalars["ID"];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  readonly settingValue: IpAllowListForInstalledAppsEnabledSettingValue;
};

/** Autogenerated input type of UpdateIssueComment */
export type UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the IssueComment to modify. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of UpdateIssue */
export type UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  readonly assigneeIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The body for the issue description. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the Issue to modify. */
  readonly id: Scalars["ID"];
  /** An array of Node IDs of labels for this issue. */
  readonly labelIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The Node ID of the milestone for this issue. */
  readonly milestoneId: Maybe<Scalars["ID"]>;
  /** An array of Node IDs for projects associated with this issue. */
  readonly projectIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The desired issue state. */
  readonly state: Maybe<IssueState>;
  /** The title for the issue. */
  readonly title: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateLabel */
export type UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  readonly color: Maybe<Scalars["String"]>;
  /** A brief description of the label, such as its purpose. */
  readonly description: Maybe<Scalars["String"]>;
  /** The Node ID of the label to be updated. */
  readonly id: Scalars["ID"];
  /** The updated name of the label. */
  readonly name: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateNotificationRestrictionSetting */
export type UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  readonly ownerId: Scalars["ID"];
  /** The value for the restrict notifications setting. */
  readonly settingValue: NotificationRestrictionSettingValue;
};

/** Autogenerated input type of UpdateProjectCard */
export type UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Whether or not the ProjectCard should be archived */
  readonly isArchived: Maybe<Scalars["Boolean"]>;
  /** The note of ProjectCard. */
  readonly note: Maybe<Scalars["String"]>;
  /** The ProjectCard ID to update. */
  readonly projectCardId: Scalars["ID"];
};

/** Autogenerated input type of UpdateProjectColumn */
export type UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of project column. */
  readonly name: Scalars["String"];
  /** The ProjectColumn ID to update. */
  readonly projectColumnId: Scalars["ID"];
};

/** Autogenerated input type of UpdateProject */
export type UpdateProjectInput = {
  /** The description of project. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The name of project. */
  readonly name: Maybe<Scalars["String"]>;
  /** The Project ID to update. */
  readonly projectId: Scalars["ID"];
  /** Whether the project is public or not. */
  readonly public: Maybe<Scalars["Boolean"]>;
  /** Whether the project is open or closed. */
  readonly state: Maybe<ProjectState>;
};

/** Autogenerated input type of UpdatePullRequest */
export type UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  readonly assigneeIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  readonly baseRefName: Maybe<Scalars["String"]>;
  /** The contents of the pull request. */
  readonly body: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** An array of Node IDs of labels for this pull request. */
  readonly labelIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** Indicates whether maintainers can modify the pull request. */
  readonly maintainerCanModify: Maybe<Scalars["Boolean"]>;
  /** The Node ID of the milestone for this pull request. */
  readonly milestoneId: Maybe<Scalars["ID"]>;
  /** An array of Node IDs for projects associated with this pull request. */
  readonly projectIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The Node ID of the pull request. */
  readonly pullRequestId: Scalars["ID"];
  /** The target state of the pull request. */
  readonly state: Maybe<PullRequestUpdateState>;
  /** The title of the pull request. */
  readonly title: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the comment to modify. */
  readonly pullRequestReviewCommentId: Scalars["ID"];
};

/** Autogenerated input type of UpdatePullRequestReview */
export type UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  readonly body: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the pull request review to modify. */
  readonly pullRequestReviewId: Scalars["ID"];
};

/** Autogenerated input type of UpdateRef */
export type UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  readonly force: Maybe<Scalars["Boolean"]>;
  /** The GitObjectID that the Ref shall be updated to target. */
  readonly oid: Scalars["GitObjectID"];
  /** The Node ID of the Ref to be updated. */
  readonly refId: Scalars["ID"];
};

/** Autogenerated input type of UpdateRefs */
export type UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** A list of ref updates. */
  readonly refUpdates: ReadonlyArray<RefUpdate>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
};

/** Autogenerated input type of UpdateRepository */
export type UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  readonly description: Maybe<Scalars["String"]>;
  /** Indicates if the repository should have the issues feature enabled. */
  readonly hasIssuesEnabled: Maybe<Scalars["Boolean"]>;
  /** Indicates if the repository should have the project boards feature enabled. */
  readonly hasProjectsEnabled: Maybe<Scalars["Boolean"]>;
  /** Indicates if the repository should have the wiki feature enabled. */
  readonly hasWikiEnabled: Maybe<Scalars["Boolean"]>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  readonly homepageUrl: Maybe<Scalars["URI"]>;
  /** The new name of the repository. */
  readonly name: Maybe<Scalars["String"]>;
  /** The ID of the repository to update. */
  readonly repositoryId: Scalars["ID"];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  readonly template: Maybe<Scalars["Boolean"]>;
};

/** Autogenerated input type of UpdateSponsorshipPreferences */
export type UpdateSponsorshipPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  readonly privacyLevel: Maybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  readonly receiveEmails: Maybe<Scalars["Boolean"]>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  readonly sponsorId: Maybe<Scalars["ID"]>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  readonly sponsorLogin: Maybe<Scalars["String"]>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  readonly sponsorableId: Maybe<Scalars["ID"]>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  readonly sponsorableLogin: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateSubscription */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The new state of the subscription. */
  readonly state: SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  readonly subscribableId: Scalars["ID"];
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  readonly body: Scalars["String"];
  /** The current version of the body content. */
  readonly bodyVersion: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the comment to modify. */
  readonly id: Scalars["ID"];
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  readonly body: Maybe<Scalars["String"]>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  readonly bodyVersion: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the discussion to modify. */
  readonly id: Scalars["ID"];
  /** If provided, sets the pinned state of the updated discussion. */
  readonly pinned: Maybe<Scalars["Boolean"]>;
  /** The updated title of the discussion. */
  readonly title: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
export type UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  readonly algorithm: Maybe<TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** Turn on or off review assignment */
  readonly enabled: Scalars["Boolean"];
  /** An array of team member IDs to exclude */
  readonly excludedTeamMemberIds: Maybe<ReadonlyArray<Scalars["ID"]>>;
  /** The Node ID of the team to update review assignments of */
  readonly id: Scalars["ID"];
  /** Notify the entire team of the PR if it is delegated */
  readonly notifyTeam: Maybe<Scalars["Boolean"]>;
  /** The number of team members to assign */
  readonly teamMemberCount: Maybe<Scalars["Int"]>;
};

/** Autogenerated input type of UpdateTopics */
export type UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars["ID"];
  /** An array of topic names. */
  readonly topicNames: ReadonlyArray<Scalars["String"]>;
};

/** The possible durations that a user can be blocked for. */
export enum UserBlockDuration {
  /** The user was blocked for 1 day */
  OneDay = "ONE_DAY",
  /** The user was blocked for 30 days */
  OneMonth = "ONE_MONTH",
  /** The user was blocked for 7 days */
  OneWeek = "ONE_WEEK",
  /** The user was blocked permanently */
  Permanent = "PERMANENT",
  /** The user was blocked for 3 days */
  ThreeDays = "THREE_DAYS",
}

/** Ordering options for user status connections. */
export type UserStatusOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order user statuses by. */
  readonly field: UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export enum UserStatusOrderField {
  /** Order user statuses by when they were updated. */
  UpdatedAt = "UPDATED_AT",
}

/** Ordering options for verifiable domain connections. */
export type VerifiableDomainOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order verifiable domains by. */
  readonly field: VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
export enum VerifiableDomainOrderField {
  /** Order verifiable domains by their creation date. */
  CreatedAt = "CREATED_AT",
  /** Order verifiable domains by the domain name. */
  Domain = "DOMAIN",
}

/** Autogenerated input type of VerifyVerifiableDomain */
export type VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId: Maybe<Scalars["String"]>;
  /** The ID of the verifiable domain to verify. */
  readonly id: Scalars["ID"];
};

export type UserInfoQueryVariables = Exact<{ [key: string]: never }>;

export type UserInfoQuery = {
  readonly __typename: "Query";
  readonly viewer: {
    readonly __typename: "User";
    readonly login: string;
    readonly avatarUrl: string;
  };
};

export type LabelFieldsFragment = {
  readonly __typename: "Label";
  readonly id: string;
  readonly name: string;
  readonly color: string;
  readonly url: string;
};

export type RepositoryFieldsFragment = {
  readonly __typename: "Repository";
  readonly id: string;
  readonly url: string;
  readonly name: string;
  readonly owner:
    | { readonly __typename: "Organization"; readonly login: string }
    | { readonly __typename: "User"; readonly login: string };
};

export type IssueFieldsFragment = {
  readonly __typename: "Issue";
  readonly id: string;
  readonly number: number;
  readonly title: string;
  readonly url: string;
  readonly closedAt: Maybe<string>;
  readonly issueState: IssueState;
  readonly labels: Maybe<{
    readonly __typename: "LabelConnection";
    readonly nodes: Maybe<
      ReadonlyArray<
        Maybe<{
          readonly __typename: "Label";
          readonly id: string;
          readonly name: string;
          readonly color: string;
          readonly url: string;
        }>
      >
    >;
  }>;
  readonly repository: {
    readonly __typename: "Repository";
    readonly id: string;
    readonly url: string;
    readonly name: string;
    readonly owner:
      | { readonly __typename: "Organization"; readonly login: string }
      | { readonly __typename: "User"; readonly login: string };
  };
};

export type PrFieldsFragment = {
  readonly __typename: "PullRequest";
  readonly id: string;
  readonly number: number;
  readonly title: string;
  readonly url: string;
  readonly closedAt: Maybe<string>;
  readonly prState: PullRequestState;
  readonly labels: Maybe<{
    readonly __typename: "LabelConnection";
    readonly nodes: Maybe<
      ReadonlyArray<
        Maybe<{
          readonly __typename: "Label";
          readonly id: string;
          readonly name: string;
          readonly color: string;
          readonly url: string;
        }>
      >
    >;
  }>;
  readonly repository: {
    readonly __typename: "Repository";
    readonly id: string;
    readonly url: string;
    readonly name: string;
    readonly owner:
      | { readonly __typename: "Organization"; readonly login: string }
      | { readonly __typename: "User"; readonly login: string };
  };
};

export type IssueLikeQueryVariables = Exact<{
  owner: Scalars["String"];
  repo: Scalars["String"];
  number: Scalars["Int"];
}>;

export type IssueLikeQuery = {
  readonly __typename: "Query";
  readonly repository: Maybe<{
    readonly __typename: "Repository";
    readonly issueOrPullRequest: Maybe<
      | {
          readonly __typename: "Issue";
          readonly id: string;
          readonly number: number;
          readonly title: string;
          readonly url: string;
          readonly closedAt: Maybe<string>;
          readonly issueState: IssueState;
          readonly labels: Maybe<{
            readonly __typename: "LabelConnection";
            readonly nodes: Maybe<
              ReadonlyArray<
                Maybe<{
                  readonly __typename: "Label";
                  readonly id: string;
                  readonly name: string;
                  readonly color: string;
                  readonly url: string;
                }>
              >
            >;
          }>;
          readonly repository: {
            readonly __typename: "Repository";
            readonly id: string;
            readonly url: string;
            readonly name: string;
            readonly owner:
              | { readonly __typename: "Organization"; readonly login: string }
              | { readonly __typename: "User"; readonly login: string };
          };
        }
      | {
          readonly __typename: "PullRequest";
          readonly id: string;
          readonly number: number;
          readonly title: string;
          readonly url: string;
          readonly closedAt: Maybe<string>;
          readonly prState: PullRequestState;
          readonly labels: Maybe<{
            readonly __typename: "LabelConnection";
            readonly nodes: Maybe<
              ReadonlyArray<
                Maybe<{
                  readonly __typename: "Label";
                  readonly id: string;
                  readonly name: string;
                  readonly color: string;
                  readonly url: string;
                }>
              >
            >;
          }>;
          readonly repository: {
            readonly __typename: "Repository";
            readonly id: string;
            readonly url: string;
            readonly name: string;
            readonly owner:
              | { readonly __typename: "Organization"; readonly login: string }
              | { readonly __typename: "User"; readonly login: string };
          };
        }
    >;
  }>;
};

export type SearchQueryVariables = Exact<{
  terms: Scalars["String"];
  after: Maybe<Scalars["String"]>;
}>;

export type SearchQuery = {
  readonly __typename: "Query";
  readonly search: {
    readonly __typename: "SearchResultItemConnection";
    readonly pageInfo: {
      readonly __typename: "PageInfo";
      readonly endCursor: Maybe<string>;
      readonly hasNextPage: boolean;
    };
    readonly nodes: Maybe<
      ReadonlyArray<
        Maybe<
          | { readonly __typename: "App" }
          | { readonly __typename: "Discussion" }
          | {
              readonly __typename: "Issue";
              readonly id: string;
              readonly number: number;
              readonly title: string;
              readonly url: string;
              readonly closedAt: Maybe<string>;
              readonly issueState: IssueState;
              readonly labels: Maybe<{
                readonly __typename: "LabelConnection";
                readonly nodes: Maybe<
                  ReadonlyArray<
                    Maybe<{
                      readonly __typename: "Label";
                      readonly id: string;
                      readonly name: string;
                      readonly color: string;
                      readonly url: string;
                    }>
                  >
                >;
              }>;
              readonly repository: {
                readonly __typename: "Repository";
                readonly id: string;
                readonly url: string;
                readonly name: string;
                readonly owner:
                  | {
                      readonly __typename: "Organization";
                      readonly login: string;
                    }
                  | { readonly __typename: "User"; readonly login: string };
              };
            }
          | { readonly __typename: "MarketplaceListing" }
          | { readonly __typename: "Organization" }
          | {
              readonly __typename: "PullRequest";
              readonly id: string;
              readonly number: number;
              readonly title: string;
              readonly url: string;
              readonly closedAt: Maybe<string>;
              readonly prState: PullRequestState;
              readonly labels: Maybe<{
                readonly __typename: "LabelConnection";
                readonly nodes: Maybe<
                  ReadonlyArray<
                    Maybe<{
                      readonly __typename: "Label";
                      readonly id: string;
                      readonly name: string;
                      readonly color: string;
                      readonly url: string;
                    }>
                  >
                >;
              }>;
              readonly repository: {
                readonly __typename: "Repository";
                readonly id: string;
                readonly url: string;
                readonly name: string;
                readonly owner:
                  | {
                      readonly __typename: "Organization";
                      readonly login: string;
                    }
                  | { readonly __typename: "User"; readonly login: string };
              };
            }
          | { readonly __typename: "Repository" }
          | { readonly __typename: "User" }
        >
      >
    >;
  };
};

export type NodeQueryVariables = Exact<{
  nodeId: Scalars["ID"];
}>;

export type NodeQuery = {
  readonly __typename: "Query";
  readonly node: Maybe<
    | { readonly __typename: "AddedToProjectEvent" }
    | { readonly __typename: "App" }
    | { readonly __typename: "AssignedEvent" }
    | { readonly __typename: "AutoMergeDisabledEvent" }
    | { readonly __typename: "AutoMergeEnabledEvent" }
    | { readonly __typename: "AutoRebaseEnabledEvent" }
    | { readonly __typename: "AutoSquashEnabledEvent" }
    | { readonly __typename: "AutomaticBaseChangeFailedEvent" }
    | { readonly __typename: "AutomaticBaseChangeSucceededEvent" }
    | { readonly __typename: "BaseRefChangedEvent" }
    | { readonly __typename: "BaseRefDeletedEvent" }
    | { readonly __typename: "BaseRefForcePushedEvent" }
    | { readonly __typename: "Blob" }
    | { readonly __typename: "Bot" }
    | { readonly __typename: "BranchProtectionRule" }
    | { readonly __typename: "CWE" }
    | { readonly __typename: "CheckRun" }
    | { readonly __typename: "CheckSuite" }
    | { readonly __typename: "ClosedEvent" }
    | { readonly __typename: "CodeOfConduct" }
    | { readonly __typename: "CommentDeletedEvent" }
    | { readonly __typename: "Commit" }
    | { readonly __typename: "CommitComment" }
    | { readonly __typename: "CommitCommentThread" }
    | { readonly __typename: "ConnectedEvent" }
    | { readonly __typename: "ConvertToDraftEvent" }
    | { readonly __typename: "ConvertedNoteToIssueEvent" }
    | { readonly __typename: "CrossReferencedEvent" }
    | { readonly __typename: "DemilestonedEvent" }
    | { readonly __typename: "DependencyGraphManifest" }
    | { readonly __typename: "DeployKey" }
    | { readonly __typename: "DeployedEvent" }
    | { readonly __typename: "Deployment" }
    | { readonly __typename: "DeploymentEnvironmentChangedEvent" }
    | { readonly __typename: "DeploymentReview" }
    | { readonly __typename: "DeploymentStatus" }
    | { readonly __typename: "DisconnectedEvent" }
    | { readonly __typename: "Discussion" }
    | { readonly __typename: "DiscussionCategory" }
    | { readonly __typename: "DiscussionComment" }
    | { readonly __typename: "Enterprise" }
    | { readonly __typename: "EnterpriseAdministratorInvitation" }
    | { readonly __typename: "EnterpriseIdentityProvider" }
    | { readonly __typename: "EnterpriseRepositoryInfo" }
    | { readonly __typename: "EnterpriseServerInstallation" }
    | { readonly __typename: "EnterpriseServerUserAccount" }
    | { readonly __typename: "EnterpriseServerUserAccountEmail" }
    | { readonly __typename: "EnterpriseServerUserAccountsUpload" }
    | { readonly __typename: "EnterpriseUserAccount" }
    | { readonly __typename: "Environment" }
    | { readonly __typename: "ExternalIdentity" }
    | { readonly __typename: "Gist" }
    | { readonly __typename: "GistComment" }
    | { readonly __typename: "HeadRefDeletedEvent" }
    | { readonly __typename: "HeadRefForcePushedEvent" }
    | { readonly __typename: "HeadRefRestoredEvent" }
    | { readonly __typename: "IpAllowListEntry" }
    | {
        readonly __typename: "Issue";
        readonly id: string;
        readonly number: number;
        readonly title: string;
        readonly url: string;
        readonly closedAt: Maybe<string>;
        readonly issueState: IssueState;
        readonly labels: Maybe<{
          readonly __typename: "LabelConnection";
          readonly nodes: Maybe<
            ReadonlyArray<
              Maybe<{
                readonly __typename: "Label";
                readonly id: string;
                readonly name: string;
                readonly color: string;
                readonly url: string;
              }>
            >
          >;
        }>;
        readonly repository: {
          readonly __typename: "Repository";
          readonly id: string;
          readonly url: string;
          readonly name: string;
          readonly owner:
            | { readonly __typename: "Organization"; readonly login: string }
            | { readonly __typename: "User"; readonly login: string };
        };
      }
    | { readonly __typename: "IssueComment" }
    | { readonly __typename: "Label" }
    | { readonly __typename: "LabeledEvent" }
    | { readonly __typename: "Language" }
    | { readonly __typename: "License" }
    | { readonly __typename: "LockedEvent" }
    | { readonly __typename: "Mannequin" }
    | { readonly __typename: "MarkedAsDuplicateEvent" }
    | { readonly __typename: "MarketplaceCategory" }
    | { readonly __typename: "MarketplaceListing" }
    | { readonly __typename: "MembersCanDeleteReposClearAuditEntry" }
    | { readonly __typename: "MembersCanDeleteReposDisableAuditEntry" }
    | { readonly __typename: "MembersCanDeleteReposEnableAuditEntry" }
    | { readonly __typename: "MentionedEvent" }
    | { readonly __typename: "MergedEvent" }
    | { readonly __typename: "Milestone" }
    | { readonly __typename: "MilestonedEvent" }
    | { readonly __typename: "MovedColumnsInProjectEvent" }
    | { readonly __typename: "OauthApplicationCreateAuditEntry" }
    | { readonly __typename: "OrgAddBillingManagerAuditEntry" }
    | { readonly __typename: "OrgAddMemberAuditEntry" }
    | { readonly __typename: "OrgBlockUserAuditEntry" }
    | { readonly __typename: "OrgConfigDisableCollaboratorsOnlyAuditEntry" }
    | { readonly __typename: "OrgConfigEnableCollaboratorsOnlyAuditEntry" }
    | { readonly __typename: "OrgCreateAuditEntry" }
    | { readonly __typename: "OrgDisableOauthAppRestrictionsAuditEntry" }
    | { readonly __typename: "OrgDisableSamlAuditEntry" }
    | { readonly __typename: "OrgDisableTwoFactorRequirementAuditEntry" }
    | { readonly __typename: "OrgEnableOauthAppRestrictionsAuditEntry" }
    | { readonly __typename: "OrgEnableSamlAuditEntry" }
    | { readonly __typename: "OrgEnableTwoFactorRequirementAuditEntry" }
    | { readonly __typename: "OrgInviteMemberAuditEntry" }
    | { readonly __typename: "OrgInviteToBusinessAuditEntry" }
    | { readonly __typename: "OrgOauthAppAccessApprovedAuditEntry" }
    | { readonly __typename: "OrgOauthAppAccessDeniedAuditEntry" }
    | { readonly __typename: "OrgOauthAppAccessRequestedAuditEntry" }
    | { readonly __typename: "OrgRemoveBillingManagerAuditEntry" }
    | { readonly __typename: "OrgRemoveMemberAuditEntry" }
    | { readonly __typename: "OrgRemoveOutsideCollaboratorAuditEntry" }
    | { readonly __typename: "OrgRestoreMemberAuditEntry" }
    | { readonly __typename: "OrgUnblockUserAuditEntry" }
    | { readonly __typename: "OrgUpdateDefaultRepositoryPermissionAuditEntry" }
    | { readonly __typename: "OrgUpdateMemberAuditEntry" }
    | {
        readonly __typename: "OrgUpdateMemberRepositoryCreationPermissionAuditEntry";
      }
    | {
        readonly __typename: "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry";
      }
    | { readonly __typename: "Organization" }
    | { readonly __typename: "OrganizationIdentityProvider" }
    | { readonly __typename: "OrganizationInvitation" }
    | { readonly __typename: "Package" }
    | { readonly __typename: "PackageFile" }
    | { readonly __typename: "PackageTag" }
    | { readonly __typename: "PackageVersion" }
    | { readonly __typename: "PinnedDiscussion" }
    | { readonly __typename: "PinnedEvent" }
    | { readonly __typename: "PinnedIssue" }
    | { readonly __typename: "PrivateRepositoryForkingDisableAuditEntry" }
    | { readonly __typename: "PrivateRepositoryForkingEnableAuditEntry" }
    | { readonly __typename: "Project" }
    | { readonly __typename: "ProjectCard" }
    | { readonly __typename: "ProjectColumn" }
    | { readonly __typename: "PublicKey" }
    | {
        readonly __typename: "PullRequest";
        readonly id: string;
        readonly number: number;
        readonly title: string;
        readonly url: string;
        readonly closedAt: Maybe<string>;
        readonly prState: PullRequestState;
        readonly labels: Maybe<{
          readonly __typename: "LabelConnection";
          readonly nodes: Maybe<
            ReadonlyArray<
              Maybe<{
                readonly __typename: "Label";
                readonly id: string;
                readonly name: string;
                readonly color: string;
                readonly url: string;
              }>
            >
          >;
        }>;
        readonly repository: {
          readonly __typename: "Repository";
          readonly id: string;
          readonly url: string;
          readonly name: string;
          readonly owner:
            | { readonly __typename: "Organization"; readonly login: string }
            | { readonly __typename: "User"; readonly login: string };
        };
      }
    | { readonly __typename: "PullRequestCommit" }
    | { readonly __typename: "PullRequestCommitCommentThread" }
    | { readonly __typename: "PullRequestReview" }
    | { readonly __typename: "PullRequestReviewComment" }
    | { readonly __typename: "PullRequestReviewThread" }
    | { readonly __typename: "Push" }
    | { readonly __typename: "PushAllowance" }
    | { readonly __typename: "Reaction" }
    | { readonly __typename: "ReadyForReviewEvent" }
    | { readonly __typename: "Ref" }
    | { readonly __typename: "ReferencedEvent" }
    | { readonly __typename: "Release" }
    | { readonly __typename: "ReleaseAsset" }
    | { readonly __typename: "RemovedFromProjectEvent" }
    | { readonly __typename: "RenamedTitleEvent" }
    | { readonly __typename: "ReopenedEvent" }
    | { readonly __typename: "RepoAccessAuditEntry" }
    | { readonly __typename: "RepoAddMemberAuditEntry" }
    | { readonly __typename: "RepoAddTopicAuditEntry" }
    | { readonly __typename: "RepoArchivedAuditEntry" }
    | { readonly __typename: "RepoChangeMergeSettingAuditEntry" }
    | { readonly __typename: "RepoConfigDisableAnonymousGitAccessAuditEntry" }
    | { readonly __typename: "RepoConfigDisableCollaboratorsOnlyAuditEntry" }
    | { readonly __typename: "RepoConfigDisableContributorsOnlyAuditEntry" }
    | { readonly __typename: "RepoConfigDisableSockpuppetDisallowedAuditEntry" }
    | { readonly __typename: "RepoConfigEnableAnonymousGitAccessAuditEntry" }
    | { readonly __typename: "RepoConfigEnableCollaboratorsOnlyAuditEntry" }
    | { readonly __typename: "RepoConfigEnableContributorsOnlyAuditEntry" }
    | { readonly __typename: "RepoConfigEnableSockpuppetDisallowedAuditEntry" }
    | { readonly __typename: "RepoConfigLockAnonymousGitAccessAuditEntry" }
    | { readonly __typename: "RepoConfigUnlockAnonymousGitAccessAuditEntry" }
    | { readonly __typename: "RepoCreateAuditEntry" }
    | { readonly __typename: "RepoDestroyAuditEntry" }
    | { readonly __typename: "RepoRemoveMemberAuditEntry" }
    | { readonly __typename: "RepoRemoveTopicAuditEntry" }
    | { readonly __typename: "Repository" }
    | { readonly __typename: "RepositoryInvitation" }
    | { readonly __typename: "RepositoryTopic" }
    | { readonly __typename: "RepositoryVisibilityChangeDisableAuditEntry" }
    | { readonly __typename: "RepositoryVisibilityChangeEnableAuditEntry" }
    | { readonly __typename: "RepositoryVulnerabilityAlert" }
    | { readonly __typename: "ReviewDismissalAllowance" }
    | { readonly __typename: "ReviewDismissedEvent" }
    | { readonly __typename: "ReviewRequest" }
    | { readonly __typename: "ReviewRequestRemovedEvent" }
    | { readonly __typename: "ReviewRequestedEvent" }
    | { readonly __typename: "SavedReply" }
    | { readonly __typename: "SecurityAdvisory" }
    | { readonly __typename: "SponsorsActivity" }
    | { readonly __typename: "SponsorsListing" }
    | { readonly __typename: "SponsorsTier" }
    | { readonly __typename: "Sponsorship" }
    | { readonly __typename: "SponsorshipNewsletter" }
    | { readonly __typename: "Status" }
    | { readonly __typename: "StatusCheckRollup" }
    | { readonly __typename: "StatusContext" }
    | { readonly __typename: "SubscribedEvent" }
    | { readonly __typename: "Tag" }
    | { readonly __typename: "Team" }
    | { readonly __typename: "TeamAddMemberAuditEntry" }
    | { readonly __typename: "TeamAddRepositoryAuditEntry" }
    | { readonly __typename: "TeamChangeParentTeamAuditEntry" }
    | { readonly __typename: "TeamDiscussion" }
    | { readonly __typename: "TeamDiscussionComment" }
    | { readonly __typename: "TeamRemoveMemberAuditEntry" }
    | { readonly __typename: "TeamRemoveRepositoryAuditEntry" }
    | { readonly __typename: "Topic" }
    | { readonly __typename: "TransferredEvent" }
    | { readonly __typename: "Tree" }
    | { readonly __typename: "UnassignedEvent" }
    | { readonly __typename: "UnlabeledEvent" }
    | { readonly __typename: "UnlockedEvent" }
    | { readonly __typename: "UnmarkedAsDuplicateEvent" }
    | { readonly __typename: "UnpinnedEvent" }
    | { readonly __typename: "UnsubscribedEvent" }
    | { readonly __typename: "User" }
    | { readonly __typename: "UserBlockedEvent" }
    | { readonly __typename: "UserContentEdit" }
    | { readonly __typename: "UserStatus" }
    | { readonly __typename: "VerifiableDomain" }
    | { readonly __typename: "Workflow" }
    | { readonly __typename: "WorkflowRun" }
  >;
};

export const LabelFieldsFragmentDoc = gql`
  fragment labelFields on Label {
    id
    name
    color
    url
  }
`;
export const RepositoryFieldsFragmentDoc = gql`
  fragment repositoryFields on Repository {
    id
    url
    owner {
      login
    }
    name
  }
`;
export const IssueFieldsFragmentDoc = gql`
  fragment issueFields on Issue {
    id
    number
    title
    url
    issueState: state
    closedAt
    labels(first: 10) {
      nodes {
        ...labelFields
      }
    }
    repository {
      ...repositoryFields
    }
  }
  ${LabelFieldsFragmentDoc}
  ${RepositoryFieldsFragmentDoc}
`;
export const PrFieldsFragmentDoc = gql`
  fragment prFields on PullRequest {
    id
    number
    title
    url
    prState: state
    closedAt
    labels(first: 10) {
      nodes {
        ...labelFields
      }
    }
    repository {
      ...repositoryFields
    }
  }
  ${LabelFieldsFragmentDoc}
  ${RepositoryFieldsFragmentDoc}
`;
export const UserInfoDocument = gql`
  query UserInfo {
    viewer {
      login
      avatarUrl(size: 24)
    }
  }
`;
export const IssueLikeDocument = gql`
  query IssueLike($owner: String!, $repo: String!, $number: Int!) {
    repository(owner: $owner, name: $repo) {
      issueOrPullRequest(number: $number) {
        __typename
        ...issueFields
        ...prFields
      }
    }
  }
  ${IssueFieldsFragmentDoc}
  ${PrFieldsFragmentDoc}
`;
export const SearchDocument = gql`
  query Search($terms: String!, $after: String) {
    search(query: $terms, type: ISSUE, first: 100, after: $after) {
      pageInfo {
        endCursor
        hasNextPage
      }
      nodes {
        __typename
        ...issueFields
        ...prFields
      }
    }
  }
  ${IssueFieldsFragmentDoc}
  ${PrFieldsFragmentDoc}
`;
export const NodeDocument = gql`
  query Node($nodeId: ID!) {
    node(id: $nodeId) {
      __typename
      ...issueFields
      ...prFields
    }
  }
  ${IssueFieldsFragmentDoc}
  ${PrFieldsFragmentDoc}
`;
export type Requester<C = {}> = <R, V>(
  doc: DocumentNode,
  vars?: V,
  options?: C,
) => Promise<R>;
export function getSdk<C>(requester: Requester<C>) {
  return {
    UserInfo(
      variables?: UserInfoQueryVariables,
      options?: C,
    ): Promise<UserInfoQuery> {
      return requester<UserInfoQuery, UserInfoQueryVariables>(
        UserInfoDocument,
        variables,
        options,
      );
    },
    IssueLike(
      variables: IssueLikeQueryVariables,
      options?: C,
    ): Promise<IssueLikeQuery> {
      return requester<IssueLikeQuery, IssueLikeQueryVariables>(
        IssueLikeDocument,
        variables,
        options,
      );
    },
    Search(variables: SearchQueryVariables, options?: C): Promise<SearchQuery> {
      return requester<SearchQuery, SearchQueryVariables>(
        SearchDocument,
        variables,
        options,
      );
    },
    Node(variables: NodeQueryVariables, options?: C): Promise<NodeQuery> {
      return requester<NodeQuery, NodeQueryVariables>(
        NodeDocument,
        variables,
        options,
      );
    },
  };
}
export type Sdk = ReturnType<typeof getSdk>;
